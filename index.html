<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASPI Strategist Embedding Explorer</title> <!-- Version bump -->

    <!-- External Libraries -->
    <!-- D3.js for data manipulation, scales, axes, zoom, brush, etc. -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <!-- jQuery for Select2 dependency -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <!-- Select2 for enhanced multi-select dropdown -->
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>

    <style>
        /* --- Base Layout and Dark Theme Styles --- */
        body {
            margin: 0;
            font-family: sans-serif;
            overflow: hidden; /* Prevent scrolling on the body */
            display: flex;
            flex-direction: column;
            height: 100vh; /* Full viewport height */
            background-color: #1e1e1e; /* Dark background */
            color: #cccccc; /* Light grey text */
        }

        #container {
            display: flex; /* Arrange controls and viz area side-by-side */
            flex: 1; /* Allow container to fill remaining vertical space */
            min-height: 0; /* Prevent flexbox overflow issues */
        }

        #controls {
            width: 280px; /* Fixed width for the control panel */
            padding: 15px;
            overflow-y: auto; /* Allow scrolling if controls exceed height */
            border-right: 1px solid #333333; /* Separator line */
            flex-shrink: 0; /* Prevent controls from shrinking */
            background-color: #252526; /* Slightly lighter dark shade */
        }

        #visualization-area {
            flex: 1; /* Allow viz area to fill remaining horizontal space */
            position: relative; /* Needed for absolute positioning of children */
            display: flex;
            flex-direction: column; /* Stack scatterplot above timeline */
            min-width: 0; /* Prevent flexbox overflow issues */
        }

        /* --- Scatterplot Area --- */
        #scatterplot-container {
            position: relative; /* For positioning canvas and SVG */
            flex: 1; /* Allow scatterplot to fill vertical space */
            width: 100%;
            min-height: 0; /* Prevent flexbox overflow issues */
        }

        #scatterplot-canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* width/height/transform set by JS */
            /* Points are drawn here */
        }

        #scatterplot-svg {
            position: absolute;
            top: 0;
            left: 0;
             /* width/height set by JS */
            pointer-events: none; /* Allow mouse events (like zoom) to pass through to canvas below */
            /* Axes, grid, and highlights are drawn here */
        }
        /* Allow pointer events only on specific SVG elements like axes if needed */
        #scatterplot-svg .axis, #scatterplot-svg .grid {
             pointer-events: auto;
        }

        /* --- Timeline Area --- */
        #timeline-container {
            width: 100%;
            height: 150px; /* Fixed height */
            border-top: 1px solid #333333; /* Separator line */
            flex-shrink: 0; /* Prevent shrinking */
            background-color: #2d2d2d; /* Dark shade */
            position: relative; /* For positioning SVG */
        }

        #timeline-svg {
            position: absolute; /* Fill the container */
            top:0;
            left:0;
            width: 100%;
            height: 100%;
        }

        /* --- Tooltip --- */
        #tooltip {
            position: absolute; /* Positioned relative to the page */
            background: rgba(45, 45, 45, 0.95); /* Dark, semi-transparent */
            border: 1px solid #555555;
            color: #eeeeee;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none; /* Tooltip shouldn't block mouse events */
            display: none; /* Hidden by default */
            max-width: 350px;
            z-index: 100; /* Ensure it's on top */
            font-size: 13px;
            line-height: 1.5;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

        /* --- Controls Styling --- */
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #444444; /* Separator between groups */
        }
         .control-group:last-child {
             border-bottom: none; /* No border for the last group */
             margin-bottom: 0;
             padding-bottom: 0;
         }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #eeeeee;
        }

        input[type="text"], select {
            background-color: #3c3c3c; /* Dark input backgrounds */
            color: #cccccc;
            border: 1px solid #555555;
            padding: 8px;
            border-radius: 4px;
            width: 100%; /* Full width within controls */
            box-sizing: border-box; /* Include padding/border in width */
        }

        /* Select2 Dark Theme Adjustments */
        .select2-container--default .select2-selection--multiple { background-color: #3c3c3c !important; border: 1px solid #555555 !important; color: #cccccc !important; }
        .select2-container--default .select2-selection--multiple .select2-selection__choice { background-color: #555555 !important; color: #eeeeee !important; border: 1px solid #666666 !important; margin-top: 2px !important; /* Ensure choices don't overlap border */ }
        .select2-container--default .select2-selection--multiple .select2-selection__choice__remove { color: #eeeeee !important; margin-left: 4px !important; }
        .select2-container--default .select2-selection--multiple .select2-selection__rendered { color: #cccccc !important; list-style: none; padding: 0 5px; margin: 0; } /* Ensure selected tags are visible */
        .select2-container--default .select2-search--inline .select2-search__field { color: #cccccc !important; margin-top: 5px !important; }
        .select2-dropdown { background-color: #2d2d2d !important; border: 1px solid #555555 !important; }
        .select2-results__option { color: #cccccc !important; }
        .select2-results__option--highlighted { background-color: #555555 !important; color: #ffffff !important; }
        .select2-container .select2-selection--multiple { min-height: 38px; } /* Ensure enough height for tags */

        /* --- D3 Element Styling --- */
        /* Timeline Brush */
        .brush .selection { fill: #777; fill-opacity: .3; stroke: #fff; }
        .brush .handle { fill: #555; stroke: #fff; }

        /* Axes */
        .axis text { font-size: 10px; fill: #cccccc; }
        .axis line, .axis path { stroke: #555555; shape-rendering: crispEdges; } /* Crisp lines */

        /* Gridlines */
        .grid line { stroke: #444444; stroke-opacity: 0.7; shape-rendering: crispEdges; }
        .grid path { stroke-width: 0; } /* Hide domain path for grid */

        /* Timeline Bars */
        .timeline-bar { fill: #810b36; /* Updated color */ }
        .timeline-bar:hover { fill: #a13b66; /* Updated hover color */ }

        /* --- Buttons and Feedback --- */
        button { background-color: #555555; color: #eeeeee; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px; transition: background-color 0.2s ease; }
        button:hover { background-color: #666666; }

        #filter-summary { margin-top: 15px; font-size: 13px; color: #aaaaaa; line-height: 1.4; }

        #loading-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px 30px; border-radius: 8px; z-index: 200; display: none; font-size: 1.1em;}

        #error-display { color: #f88; margin-top: 10px; padding: 10px; border: 1px solid #f88; border-radius: 4px; background-color: rgba(255,0,0,0.1); display: none; /* Hidden by default */ }

         /* Basic Responsiveness */
        @media (max-width: 768px) {
            #container { flex-direction: column; } /* Stack controls on top */
            #controls { width: 100%; max-height: 250px; border-right: none; border-bottom: 1px solid #333333; }
            #visualization-area { flex-grow: 1; } /* Allow viz area to fill remaining space */
            #timeline-container { height: 120px; /* Slightly smaller timeline */ }
        }
    </style>
</head>
<body>
    <!-- Loading Indicator (shown during data load/resize) -->
    <div id="loading-indicator">Loading Articles...</div>

    <!-- Main Container -->
    <div id="container">

        <!-- Control Panel (Left Side) -->
        <div id="controls">
            <h2>ASPI <em>Strategist</em> Embedding Explorer</h2>
            <p>All <em>Strategist</em> posts up to May 4 2025 are represented as points in an embedding space, in which posts with semantically-similar content appear closer. Try searching for a tag to see how topics form clusters.</p>
             <!-- Area to display errors -->
             <div id="error-display"></div>

            <!-- Search Filter -->
            <div class="control-group">
                <label for="search-input">Search Title/Author:</label>
                <input type="text" id="search-input" placeholder="Enter keywords">
                <button id="reset-search">Reset Search</button>
            </div>

            <!-- Tag Filter (using Select2) -->
            <div class="control-group">
                <label for="tag-select">Filter by Tags:</label>
                <select id="tag-select" multiple="multiple" style="width: 100%;"></select>
                <button id="reset-tags">Reset Tags</button>
            </div>

             <!-- Timeline Binning Control -->
             <div class="control-group">
                 <label for="binning-select">Timeline Granularity:</label>
                 <select id="binning-select">
                     <!-- <option value="day">Day</option> Removed Day Option -->
                     <option value="week" selected>Week</option>
                     <option value="month">Month</option>
                     <option value="year">Year</option>
                 </select>
                 <button id="reset-timeline">Reset Date Range</button>
             </div>

             <!-- Filter Summary Text -->
             <div id="filter-summary"></div>
        </div>

        <!-- Visualization Area (Right Side) -->
        <div id="visualization-area">

            <!-- Scatterplot Container -->
            <div id="scatterplot-container">
                <!-- Canvas for drawing potentially many points efficiently -->
                <canvas id="scatterplot-canvas"></canvas>
                <!-- SVG overlay for axes, gridlines, and interaction highlights (hover/sticky) -->
                <svg id="scatterplot-svg">
                    <!-- Group for scatterplot content, translated by margin -->
                    <g class="scatterplot-content">
                        <!-- Gridline groups -->
                        <g class="grid x-grid"></g>
                        <g class="grid y-grid"></g>
                        <!-- Axis groups -->
                        <g class="axis x-axis"></g>
                        <g class="axis y-axis"></g>
                        <!-- Circles for highlighting points, drawn on top -->
                        <circle class="hover-highlight" r="6" fill="none" stroke="#00ffff" stroke-width="1.5" pointer-events="none" display="none"></circle>
                         <circle class="sticky-highlight" r="6" fill="none" stroke="#ffcc00" stroke-width="1.5" pointer-events="none" display="none"></circle>
                    </g>
                </svg>
            </div>

            <!-- Timeline Container -->
            <div id="timeline-container">
                <!-- SVG for timeline elements -->
                <svg id="timeline-svg">
                    <!-- Group for timeline content, translated by margin -->
                     <g class="timeline-content">
                         <!-- Group to hold the histogram bars -->
                         <g class="timeline-bars"></g>
                         <!-- Group for the time axis -->
                         <g class="axis time-axis"></g>
                         <!-- Group for the D3 brush component -->
                         <g class="brush"></g>
                     </g>
                </svg>
            </div>

            <!-- Tooltip Element (absolutely positioned on the page) -->
            <div id="tooltip"></div>
        </div>
    </div>

    <!-- Main JavaScript Logic -->
    <script type="module"> // Use module scope to avoid polluting global namespace

        // --- Configuration Constants ---
        // Central place for tweaking visualization parameters
        const CONFIG = {
            dataUrl: 'articles.json', // Path to the data file
            scatterplotMargin: { top: 20, right: 20, bottom: 40, left: 50 }, // Margins for scatterplot SVG/Canvas layout
            timelineMargin: { top: 10, right: 20, bottom: 30, left: 50 }, // Margins for timeline SVG layout
            pointRadius: 3,       // Default radius of points on scatterplot
            highlightRadius: 5,   // Radius of points highlighted by tag filter
            pointColor: '#810b36', // Default color of points and timeline bars (Updated)
            highlightColor: '#ffcc00', // Color for points matching selected tags
            deEmphasisColor: '#444444', // Color for points NOT matching selected tags (when tags are selected)
            hoverHighlightColor: '#00ffff', // Stroke color for SVG circle on hover
            stickyHighlightColor: '#ffcc00', // Stroke color for SVG circle on click (sticky)
            timelineBarColor: '#810b36', // Base color for timeline bars (Updated)
            timelineBarHoverColor: '#a13b66', // Color for timeline bar on hover (Updated)
            zoomMin: 0.5,        // Minimum zoom level for scatterplot
            zoomMax: 20,         // Maximum zoom level for scatterplot
            debounceTime: 250,   // Delay (ms) for debouncing search input and resize events
            tooltipOffsetX: 0,   // Horizontal offset of tooltip from cursor (Reduced)
            tooltipOffsetY: 0    // Vertical offset of tooltip from cursor (Reduced)
        };

        // --- Application State ---
        // Single object to hold all dynamic data and state information
        const appState = {
            fullData: [],        // Array holding all processed article objects
            filteredData: [],    // Array holding articles matching current filters (search, tags, date)
            uniqueTags: new Set(), // Set of all unique tags found in the data

            // Current filter settings
            currentFilters: {
                dateRange: null,       // [startDate, endDate] from timeline brush, or null if no brush
                selectedTags: new Set(), // Set of currently selected tags from dropdown
                searchQuery: ''        // Current text in the search input
            },
            // currentBinning removed - read directly from dropdown in drawTimeline

            currentTransform: d3.zoomIdentity, // Current zoom/pan state from d3.zoom

            // Calculated dimensions of SVG/Canvas areas (excluding margins)
            dimensions: {
                scatterplot: { width: 0, height: 0 },
                timeline: { width: 0, height: 0 }
            },
            // D3 scale objects
            scales: {
                x: null,     // Scatterplot X (linear)
                y: null,     // Scatterplot Y (linear)
                time: null,  // Timeline X (time)
                count: null  // Timeline Y (linear, for bar height)
            },
            // D3 axis generator objects
            axes: {
                x: null, y: null, time: null, // Base axes
                xGrid: null, yGrid: null      // Gridline axes
            },
            // D3 behavior objects
            behaviors: {
                zoom: null, // d3.zoom behavior instance
                brush: null // d3.brushX behavior instance
            },
            quadtree: null,        // d3.quadtree for efficient point lookup on scatterplot
            hoveredPoint: null,    // Data object of the point currently hovered over
            stickyPoint: null,     // Data object of the point last clicked (sticky tooltip)
            timelineHoveredBin: null, // Date range {x0, x1} of the timeline bin hovered over
            isBrushing: false,      // Flag to prevent brush event feedback loops
            canvasContext: null     // 2D rendering context for the scatterplot canvas
        };

        // --- DOM Element Selectors ---
        // Cache D3 selections for frequently accessed elements
        const ELEMENTS = {
            loadingIndicator: d3.select("#loading-indicator"), errorDisplay: d3.select("#error-display"),
            controls: d3.select("#controls"), searchInput: d3.select("#search-input"),
            tagSelect: d3.select("#tag-select"), binningSelect: d3.select("#binning-select"),
            resetSearchBtn: d3.select("#reset-search"), resetTagsBtn: d3.select("#reset-tags"), resetTimelineBtn: d3.select("#reset-timeline"),
            filterSummary: d3.select("#filter-summary"), scatterplotContainer: d3.select("#scatterplot-container"),
            scatterplotCanvas: d3.select("#scatterplot-canvas"), scatterplotSvg: d3.select("#scatterplot-svg"),
            scatterplotContent: d3.select("#scatterplot-svg g.scatterplot-content"),
            xAxisGroup: d3.select("#scatterplot-svg g.x-axis"), yAxisGroup: d3.select("#scatterplot-svg g.y-axis"),
            xGridGroup: d3.select("#scatterplot-svg g.x-grid"), yGridGroup: d3.select("#scatterplot-svg g.y-grid"),
            hoverHighlight: d3.select("#scatterplot-svg .hover-highlight"), stickyHighlight: d3.select("#scatterplot-svg .sticky-highlight"),
            timelineContainer: d3.select("#timeline-container"), timelineSvg: d3.select("#timeline-svg"),
            timelineContent: d3.select("#timeline-svg g.timeline-content"),
            timelineBarsGroup: d3.select("#timeline-svg g.timeline-bars"), timeAxisGroup: d3.select("#timeline-svg g.time-axis"),
            timelineBrushGroup: d3.select("#timeline-svg g.brush"), tooltip: d3.select("#tooltip")
        };

        // --- Main Initialization Function ---
        // Orchestrates the setup process
        async function initialize() {
            showLoading("Loading data...");
            ELEMENTS.errorDisplay.style('display', 'none'); // Hide previous errors
            try {
                // 1. Load Data
                console.log("Fetching data...");
                const rawData = await d3.json(CONFIG.dataUrl);
                // Basic validation of fetched data structure
                if (!rawData || typeof rawData !== 'object') { throw new Error(`Failed to fetch or parse data from ${CONFIG.dataUrl}. Response was not a valid object/array.`); }
                if (!Array.isArray(rawData)) { throw new Error(`Data from ${CONFIG.dataUrl} is not an array as expected.`); }
                if (rawData.length === 0) { console.warn("Data source is empty."); } // Allow empty data? Maybe throw error?

                // 2. Process Data
                console.log("Processing data...");
                processData(rawData); // Cleans data, parses dates, checks validity. Throws error if no valid points.

                // 3. Setup UI and Visualization Components
                console.log("Setting up UI and visualization...");
                collectUniqueTags();    // Find all unique tags for the filter dropdown
                populateTagFilter();    // Populate and initialize the Select2 dropdown
                setupDimensions();      // Calculate width/height based on container size and margins
                setupScales();          // Create D3 scales based on data extents and dimensions. Calculates initial px/py. Throws error on invalid extents.
                setupAxes();            // Create D3 axis generators
                setupSVGStructure();    // Setup SVG groups and apply margin transforms
                setupCanvas();          // Setup canvas dimensions and get rendering context
                setupInteractions();    // Initialize zoom, brush, and setup event listeners

                // 4. Initial Render
                console.log("Performing initial visualization update...");
                updateVisualization(true); // Perform the first draw of all components
                setInitialTimelineBrush(); // Set the timeline brush to cover the full range initially

                console.log("Initialization complete.");
                showLoading(false); // Hide loading indicator
            } catch (error) {
                // Catch any error during initialization and display it
                console.error("Initialization failed:", error);
                showLoading(false);
                displayError(`Initialization failed: ${error.message}`);
            }
        }

        // --- Data Handling ---
        // Cleans raw data, parses dates, validates required fields (date, x, y)
        function processData(rawData) {
            appState.fullData = rawData.map((d, i) => {
                // Basic type check
                if (typeof d !== 'object' || d === null) { console.warn(`Item at index ${i} is not a valid object. Skipping.`); return null; }

                // Parse and validate date
                const date = new Date(d.date);
                if (isNaN(date.getTime())) { console.warn(`Invalid date found for item ID ${d.id || `(index ${i})`}: '${d.date}'. Skipping item.`); return null; }

                // Parse and validate coordinates
                const xVal = +d.x; const yVal = +d.y;
                if (d.x == null || d.y == null || isNaN(xVal) || isNaN(yVal)) { console.warn(`Invalid/missing coordinates for item ID ${d.id || `(index ${i})`}: x='${d.x}', y='${d.y}'. Skipping item.`); return null; }

                // Return structured object, providing defaults for optional fields
                return {
                    id: d.id || i, // Use provided ID or index as fallback
                    title: d.title || '',
                    author: d.author || 'Unknown',
                    url: d.url, // Keep URL as is
                    date: date, // Store Date object
                    tags: Array.isArray(d.tags) ? d.tags.map(String).filter(tag => tag && tag.trim() !== '') : [], // Ensure tags is array, clean up
                    x: xVal,    // Store validated number
                    y: yVal,    // Store validated number
                    px: 0,      // Placeholder for untransformed pixel X (calculated in setupScales)
                    py: 0       // Placeholder for untransformed pixel Y (calculated in setupScales)
                };
            }).filter(d => d !== null); // Remove items that failed validation

             // Ensure we have *some* valid data to proceed
             if (appState.fullData.length === 0) {
                 throw new Error("No valid data points found after processing. Check source data format and values.");
             }
             console.log(`Processed ${appState.fullData.length} valid articles.`);
        }

        // Extracts all unique tags from the processed data
        function collectUniqueTags() {
            // Use flatMap to get all tags into a single array, then Set for uniqueness
            const tags = new Set(appState.fullData.flatMap(item => item.tags));
            appState.uniqueTags = tags;
            console.log(`Found ${tags.size} unique tags.`);
        }

        // --- Filter Logic ---
        // Applies current search, tag, and date filters to the full dataset
        function applyFilters() {
            const { dateRange, selectedTags, searchQuery } = appState.currentFilters;
            const searchLower = searchQuery.toLowerCase().trim(); // Prepare search query once

            // Filter the full dataset based on combined criteria
            appState.filteredData = appState.fullData.filter(d => {
                // 1. Date Filter (from timeline brush)
                const meetsDate = !dateRange || (d.date >= dateRange[0] && d.date <= dateRange[1]);
                if (!meetsDate) return false; // Early exit if date doesn't match

                // 2. Tag Filter (OR logic: point must have at least ONE selected tag)
                const meetsTags = selectedTags.size === 0 || Array.from(selectedTags).every(tag => d.tags.includes(tag));
                if (!meetsTags) return false; // Early exit if no tag match (and tags are selected)

                // 3. Search Filter (check title and author)
                const meetsSearch = !searchLower ||
                                    (d.title && d.title.toLowerCase().includes(searchLower)) ||
                                    (d.author && d.author.toLowerCase().includes(searchLower));
                if (!meetsSearch) return false; // Early exit if no search match

                // If all checks pass, keep the data point
                return true;
            });

            // After filtering, rebuild the quadtree for efficient hover/click detection
            updateQuadtree();
        }

        // Rebuilds the quadtree based on the currently filtered data's pixel coordinates
        function updateQuadtree() {
             // Safety check: ensure px/py have been calculated (should happen in setupScales/handleResize)
             if (appState.fullData.length > 0 && appState.fullData[0].px === 0 && appState.fullData[0].py === 0 && appState.scales.x) {
                 console.warn("px/py seem uninitialized before quadtree build. Recalculating.");
                 appState.fullData.forEach(d => { d.px = appState.scales.x(d.x); d.py = appState.scales.y(d.y); });
             }
             // Build quadtree using untransformed pixel coordinates for stable searching during zoom/pan
             appState.quadtree = d3.quadtree()
                .x(d => d.px) // Use pre-calculated pixel x
                .y(d => d.py) // Use pre-calculated pixel y
                .addAll(appState.filteredData); // Add only currently filtered points
        }

        // --- UI Setup ---
        // Populates the tag filter dropdown and initializes Select2
        function populateTagFilter() {
            const sortedTags = Array.from(appState.uniqueTags).sort((a, b) => a.localeCompare(b)); // Sort tags alphabetically

            // Populate the <select> element
            ELEMENTS.tagSelect.selectAll('option').remove(); // Clear previous options
            ELEMENTS.tagSelect.selectAll('option')
                .data(sortedTags)
                .join('option') // Use D3's join pattern
                .attr('value', d => d)
                .text(d => d);

            // Initialize Select2 on the populated element
            $(ELEMENTS.tagSelect.node()).select2({
                placeholder: "Filter by one or more tags", // Placeholder text
                allowClear: true                          // Show a clear button
            });

            // Attach event listener for Select2 changes (ensure only one listener)
            $(ELEMENTS.tagSelect.node()).off('change').on('change', handleTagChange);
        }

        // Calculates the usable drawing dimensions based on container size and margins
        function setupDimensions() {
            const scRect = ELEMENTS.scatterplotContainer.node().getBoundingClientRect();
            const tlRect = ELEMENTS.timelineContainer.node().getBoundingClientRect();

            // Calculate width/height available INSIDE margins
            appState.dimensions.scatterplot.width = Math.max(10, scRect.width - CONFIG.scatterplotMargin.left - CONFIG.scatterplotMargin.right); // Ensure min width
            appState.dimensions.scatterplot.height = Math.max(10, scRect.height - CONFIG.scatterplotMargin.top - CONFIG.scatterplotMargin.bottom); // Ensure min height
            appState.dimensions.timeline.width = Math.max(10, tlRect.width - CONFIG.timelineMargin.left - CONFIG.timelineMargin.right);
            appState.dimensions.timeline.height = Math.max(10, tlRect.height - CONFIG.timelineMargin.top - CONFIG.timelineMargin.bottom);
        }

        // Creates D3 scales based on data extents and calculated dimensions
        function setupScales() {
            const scDims = appState.dimensions.scatterplot; const tlDims = appState.dimensions.timeline;

            // Find data ranges (extents)
            const xExt = d3.extent(appState.fullData, d => d.x);
            const yExt = d3.extent(appState.fullData, d => d.y);
            const dateExt = d3.extent(appState.fullData, d => d.date);

            // Validate extents - crucial to prevent errors downstream
            if (xExt[0] === undefined || xExt[1] === undefined || isNaN(xExt[0]) || isNaN(xExt[1])) { throw new Error(`Invalid numeric extent for 'x': [${xExt}]`); }
            if (yExt[0] === undefined || yExt[1] === undefined || isNaN(yExt[0]) || isNaN(yExt[1])) { throw new Error(`Invalid numeric extent for 'y': [${yExt}]`); }
            if (!dateExt[0] || !dateExt[1] || isNaN(dateExt[0].getTime()) || isNaN(dateExt[1].getTime())) { throw new Error(`Invalid date extent: [${dateExt}]`); }
            console.log("Determined extents:", {x: xExt, y: yExt, date: dateExt});

            // Create scales (mapping data domain to pixel range)
            appState.scales.x = d3.scaleLinear().domain(xExt).nice().range([0, scDims.width]);           // X: linear data to horizontal pixels
            appState.scales.y = d3.scaleLinear().domain(yExt).nice().range([scDims.height, 0]);         // Y: linear data to vertical pixels (inverted for SVG coords)
            appState.scales.time = d3.scaleTime().domain(dateExt).nice().range([0, tlDims.width]);        // Timeline X: date data to horizontal pixels
            appState.scales.count = d3.scaleLinear().range([tlDims.height, 0]); // Timeline Y: count data to vertical pixels (domain set later)

            // Pre-calculate untransformed pixel coordinates (px, py) for each point
            // This is done once after scales are set (and updated on resize)
            // Used for quadtree and potentially drawing if performance needed it
            if (!appState.scales.x || !appState.scales.y) { throw new Error("Scatterplot scales failed init before px/py calculation"); }
            appState.fullData.forEach(d => {
                d.px = appState.scales.x(d.x);
                d.py = appState.scales.y(d.y);
                // Check for issues during calculation
                if (isNaN(d.px) || isNaN(d.py)) { console.warn(`NaN pixel coord calculated for ID ${d.id}`); }
            });
            console.log("Scales setup complete. px/py calculated.");
        }

        // Creates D3 axis generators
        function setupAxes() {
            if (!appState.scales.x || !appState.scales.y || !appState.scales.time) { throw new Error("Scales must be initialized before setting up axes."); }

            // Define axis generators
            appState.axes.x = d3.axisBottom(appState.scales.x).ticks(10).tickSizeOuter(0); // Remove outer ticks for cleaner look
            appState.axes.y = d3.axisLeft(appState.scales.y).ticks(10).tickSizeOuter(0);
            appState.axes.time = d3.axisBottom(appState.scales.time).ticks(5).tickSizeOuter(0); // Fewer ticks for timeline

            // Define gridline generators (use axis generators with modified tick size/format)
            appState.axes.xGrid = d3.axisBottom(appState.scales.x).tickSize(-appState.dimensions.scatterplot.height).tickFormat(""); // Extend ticks across height, no labels
            appState.axes.yGrid = d3.axisLeft(appState.scales.y).tickSize(-appState.dimensions.scatterplot.width).tickFormat("");   // Extend ticks across width, no labels
            console.log("Axes definitions setup complete.");
        }

        // Sets up basic SVG group structure and applies margin transformations
        function setupSVGStructure() {
            const scM = CONFIG.scatterplotMargin; const tlM = CONFIG.timelineMargin;
            const scD = appState.dimensions.scatterplot; const tlD = appState.dimensions.timeline;

            // Size the SVG elements
            ELEMENTS.scatterplotSvg.attr("width", scD.width + scM.left + scM.right).attr("height", scD.height + scM.top + scM.bottom);
            ELEMENTS.timelineSvg.attr("width", tlD.width + tlM.left + tlM.right).attr("height", tlD.height + tlM.top + tlM.bottom);

            // Apply margin transformations to the main content groups
            ELEMENTS.scatterplotContent.attr("transform", `translate(${scM.left},${scM.top})`);
            ELEMENTS.timelineContent.attr("transform", `translate(${tlM.left},${tlM.top})`);

            // Position axis groups correctly within their content groups
            ELEMENTS.xAxisGroup.attr("transform", `translate(0,${scD.height})`); // Move to bottom
            ELEMENTS.xGridGroup.attr("transform", `translate(0,${scD.height})`); // Move to bottom
            ELEMENTS.timeAxisGroup.attr("transform", `translate(0,${tlD.height})`); // Move to bottom
        }

        // Sets up the scatterplot canvas dimensions and gets the drawing context
         function setupCanvas() {
            const scD = appState.dimensions.scatterplot; const scM = CONFIG.scatterplotMargin;

            // Set canvas size and position it using CSS transform to align with SVG content area
            ELEMENTS.scatterplotCanvas
                .attr("width", scD.width)
                .attr("height", scD.height)
                .style("transform", `translate(${scM.left}px, ${scM.top}px)`);

            // Get and store the 2D rendering context
            appState.canvasContext = ELEMENTS.scatterplotCanvas.node().getContext("2d");
            if (!appState.canvasContext) { throw new Error("Failed to get 2D rendering context for canvas."); }
            console.log("Canvas setup complete.");
         }

        // Initializes D3 behaviors (zoom, brush) and attaches event listeners
        function setupInteractions() {
            const scD = appState.dimensions.scatterplot; const tlD = appState.dimensions.timeline;

            // --- Zoom Behavior (Scatterplot) ---
            appState.behaviors.zoom = d3.zoom()
                .scaleExtent([CONFIG.zoomMin, CONFIG.zoomMax]) // Set min/max zoom levels
                .translateExtent([[0, 0], [scD.width, scD.height]]) // Limit panning to plot area
                .extent([[0, 0], [scD.width, scD.height]]) // Define viewport extent
                .on("zoom", handleZoom); // Attach zoom event handler

            // Apply zoom behavior to the canvas element (where mouse events occur)
            ELEMENTS.scatterplotCanvas.call(appState.behaviors.zoom);

            // --- Brush Behavior (Timeline) ---
            appState.behaviors.brush = d3.brushX() // Horizontal brush only
                .extent([[0, 0], [tlD.width, tlD.height]]) // Limit brush area to timeline drawing area
                .on("start brush end", handleBrush); // Attach brush event handler (listens for start, drag, end)

            // Apply brush behavior to the dedicated brush group in the timeline SVG
            ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush);

            // --- Control Panel Listeners ---
            ELEMENTS.searchInput.on("input", debounce(handleSearchInput, CONFIG.debounceTime)); // Debounced search
            ELEMENTS.binningSelect.on("change", handleBinningChange); // Timeline granularity change
            ELEMENTS.resetSearchBtn.on("click", resetSearch);
            ELEMENTS.resetTagsBtn.on("click", resetTags);
            ELEMENTS.resetTimelineBtn.on("click", resetTimelineBrush);
            // Note: Select2 tag filter listener is attached in populateTagFilter using jQuery

            // --- Canvas Interaction Listeners ---
            ELEMENTS.scatterplotCanvas
                .on("mousemove", handleCanvasMouseMove) // Hover detection
                .on("click", handleCanvasClick)         // Click detection (sticky tooltip, URL open)
                .on("mouseout", handleCanvasMouseOut)   // Clear hover/tooltip when leaving canvas
                .on("dblclick.zoom", null)             // Disable default D3 dblclick zoom
                .on("dblclick", handleCanvasDoubleClick); // Attach custom double-click zoom handler

            // --- Window Resize Listener ---
            // Debounce resize events to avoid excessive recalculations
            d3.select(window).on("resize", debounce(handleResize, CONFIG.debounceTime));

            console.log("Interaction listeners setup complete.");
        }


        // --- Drawing Functions ---

        // Draws the scatterplot points onto the canvas
        function drawScatterplot() {
            const ctx = appState.canvasContext;
            if (!ctx) return; // Guard against missing context
            const { width, height } = appState.dimensions.scatterplot;
            const transform = appState.currentTransform; // Current zoom/pan state
            const { selectedTags } = appState.currentFilters;
            const timelineHoverBin = appState.timelineHoveredBin;

            // --- Drawing Setup ---
            ctx.save(); // Save default context state
            ctx.clearRect(0, 0, width, height); // Clear the canvas for redraw
            ctx.translate(transform.x, transform.y); // Apply zoom/pan translation
            ctx.scale(transform.k, transform.k);     // Apply zoom scale

            // --- Point Iteration and Drawing ---
            // Iterate through only the data points that have passed the current filters
            appState.filteredData.forEach(d => {
                // Use pre-calculated untransformed pixel coordinates (px, py)
                const cx = d.px;
                const cy = d.py;
                let radius = CONFIG.pointRadius; // Start with default appearance
                let color = CONFIG.pointColor;

                // --- Apply Visual Encoding based on Filters/State ---
                // 1. Tag Filtering: Check if tags are selected AND if this point matches
                if (selectedTags.size > 0) {
                    const isHighlightedByTag = Array.from(selectedTags).every(tag => d.tags.includes(tag));
                    if (isHighlightedByTag) {
                        // Apply highlight style
                        radius = CONFIG.highlightRadius;
                        color = CONFIG.highlightColor;
                    } else {
                        // Apply de-emphasis style
                        color = CONFIG.deEmphasisColor;
                    }
                } // If no tags selected, color/radius remain default unless overridden below

                // 2. Timeline Hover Highlighting (overrides tag color)
                 if (timelineHoverBin && d.date >= timelineHoverBin.x0 && d.date < timelineHoverBin.x1) {
                     color = CONFIG.timelineBarHoverColor; // Use timeline hover color
                     radius = Math.max(radius, CONFIG.highlightRadius - 1); // Ensure highlighted size
                 }

                // --- Draw the Point ---
                // Note: Hover/Sticky highlights are handled by SVG overlays, not drawn on canvas here
                ctx.beginPath();
                // Scale radius inversely with zoom for consistent apparent size on screen
                ctx.arc(cx, cy, radius / transform.k, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
            });

            // --- Cleanup ---
            ctx.restore(); // Restore context state (removes transform)

            // Update positions/visibility of SVG highlight circles after points are drawn
            updateSVGHoverHighlight();
            updateSVGStickyHighlight();
        }

        // Draws the timeline histogram bars
        function drawTimeline() {
            const { time: timeScale, count: countScale } = appState.scales;
            if (!appState.dimensions.timeline) return; // Guard for resize timing
            const { width, height } = appState.dimensions.timeline;

            // --- Determine Binning Interval ---
            const selectedBinKey = ELEMENTS.binningSelect.property("value"); // Read current dropdown value
            const binMap = { 'week': d3.timeWeek, 'month': d3.timeMonth, 'year': d3.timeYear }; // Excludes 'day'
            const binningInterval = binMap[selectedBinKey] || d3.timeWeek; // Get the D3 interval object
            const binningFuncName = Object.keys(binMap).find(key => binMap[key] === binningInterval) || 'unknown'; // For logging

            // --- Precondition Checks ---
            if (!timeScale || !countScale || !binningInterval || width <= 0 || height <= 0) { console.error("drawTimeline preconditions failed."); return; }
            const timeDomain = timeScale.domain(); // Get the current domain from the time scale
            if (!timeDomain || timeDomain.length !== 2 || !timeDomain[0] || !timeDomain[1] || isNaN(timeDomain[0].getTime()) || isNaN(timeDomain[1].getTime())) { console.error("drawTimeline: Invalid timeScale domain."); return; }

            // --- Calculate Histogram Bins ---
            let bins = []; // Initialize bins array
            try {
                // 1. Generate threshold dates using the .range() method of the interval object
                const thresholds = binningInterval.range(timeDomain[0], timeDomain[1]);
                // 2. Validate thresholds result
                if (!Array.isArray(thresholds)) { throw new Error(`Binning interval's .range() ('${binningFuncName}') did not return an array.`); }

                // 3. Create histogram generator
                const histogram = d3.histogram()
                    .value(d => d.date)        // Accessor for date value
                    .domain(timeDomain)      // Set domain to match time scale
                    .thresholds(thresholds); // Use calculated date thresholds

                // 4. Calculate bins using the CURRENTLY FILTERED DATA
                bins = histogram(appState.filteredData);
                // console.log(`drawTimeline: ${bins.length} bins for ${appState.filteredData.length} points using '${binningFuncName}'.`); // Optional log

            } catch (error) {
                // Handle errors during bin calculation
                console.error("Error calculating histogram bins/thresholds:", error);
                displayError(`Failed to draw timeline: ${error.message}`); return; // Stop drawing
            }

            // --- Update Y Scale Domain ---
            // Set the domain of the count scale based on the maximum bin size found
            countScale.domain([0, Math.max(1, d3.max(bins, d => d.length) || 0)]).nice(); // Ensure domain max is at least 1

            // --- Draw Bars using D3 Join ---
            ELEMENTS.timelineBarsGroup.selectAll(".timeline-bar")
                .data(bins) // Bind bin data
                .join("rect") // Efficiently handle enter/update/exit
                .attr("class", "timeline-bar")
                .attr("x", d => timeScale(d.x0) + 1) // Position bar, add 1px gap
                .attr("width", d => Math.max(0, timeScale(d.x1) - timeScale(d.x0) - 1)) // Calculate width, ensure non-negative, subtract gap
                .attr("y", d => countScale(d.length)) // Position top of bar based on count
                .attr("height", d => Math.max(0, height - countScale(d.length))) // Calculate height, ensure non-negative
                .style("fill", CONFIG.timelineBarColor)
                // Attach hover listeners directly to bars
                .on("mouseover", handleTimelineBarMouseOver)
                .on("mouseout", handleTimelineBarMouseOut);

            // Update the time axis as well (in case ticks change, though unlikely here)
             if (appState.axes.time) {
                 ELEMENTS.timeAxisGroup.call(appState.axes.time);
             }
        }

        // Draws the axes and gridlines on the SVG overlay
         function drawAxes() {
            const { x: scaleX, y: scaleY } = appState.scales; // Use base scales
            const transform = appState.currentTransform; // Current zoom state

            // Guard against missing components
            if (!appState.axes.x || !appState.axes.y || !appState.axes.time || !scaleX || !scaleY) return;

            // Apply zoom transform to scatterplot scales
            const currentXScale = transform.rescaleX(scaleX);
            const currentYScale = transform.rescaleY(scaleY);

            // Call axis generators with the dynamically rescaled scales
            ELEMENTS.xAxisGroup.call(appState.axes.x.scale(currentXScale));
            ELEMENTS.yAxisGroup.call(appState.axes.y.scale(currentYScale));

            // Call gridline generators with rescaled scales
            ELEMENTS.xGridGroup.call(appState.axes.xGrid.scale(currentXScale));
            ELEMENTS.yGridGroup.call(appState.axes.yGrid.scale(currentYScale));

            // Call timeline axis generator (doesn't zoom)
            ELEMENTS.timeAxisGroup.call(appState.axes.time);
        }

        // --- Update Functions ---

        // Main function to update the visualization based on current state
        // Called after interactions, filtering, or initial load
        function updateVisualization(isInitialLoad = false) {
            // 1. Apply all current filters (search, tags, date) to update appState.filteredData
            applyFilters();

            // 2. Redraw components that depend on filtered data or zoom state
            drawAxes();        // Update axes based on current zoom/pan
            drawTimeline();    // Update timeline based on current filtered data
            drawScatterplot(); // Update points based on current filtered data and zoom/pan

            // 3. Update the summary text display
            updateFilterSummary();
        }

        // Updates the position and visibility of the SVG hover highlight circle
         function updateSVGHoverHighlight() {
             const point = appState.hoveredPoint;
             const transform = appState.currentTransform;
             // Show only if a point is hovered and it's not the sticky point
             if (point && point.id !== appState.stickyPoint?.id) {
                 // Apply current zoom transform to the point's base pixel coordinates
                 const cx = transform.applyX(point.px);
                 const cy = transform.applyY(point.py);
                 ELEMENTS.hoverHighlight
                     .attr("cx", cx)
                     .attr("cy", cy)
                     .style("display", "block"); // Make visible
             } else {
                 ELEMENTS.hoverHighlight.style("display", "none"); // Hide
             }
         }

         // Updates the position and visibility of the SVG sticky highlight circle
         function updateSVGStickyHighlight() {
             const point = appState.stickyPoint;
             const transform = appState.currentTransform;
             if (point) { // Show if a point is sticky
                 const cx = transform.applyX(point.px);
                 const cy = transform.applyY(point.py);
                 ELEMENTS.stickyHighlight
                     .attr("cx", cx)
                     .attr("cy", cy)
                     .style("display", "block"); // Make visible
             } else {
                 ELEMENTS.stickyHighlight.style("display", "none"); // Hide
             }
         }

        // --- Event Handlers ---

        // Handles D3 zoom events on the scatterplot canvas
        function handleZoom(event) {
            // Ignore zoom events triggered programmatically (e.g., by transitions or .call)
            if (!event.sourceEvent) return;

            // Update the current transform state
            appState.currentTransform = event.transform;

            // Redraw components affected by zoom/pan
            drawAxes();        // Axes need new scales
            drawScatterplot(); // Points need new transform applied (scaling radius, culling)

            // Hide tooltip during zoom/pan for cleaner interaction
            hideTooltip();

            // Update SVG highlight positions to match the new transform
            updateSVGHoverHighlight();
            updateSVGStickyHighlight();
        }

        // Handles D3 brush events on the timeline
        function handleBrush(event) {
            // Ignore brush events triggered programmatically (e.g., by .move) or during internal flag
            if (appState.isBrushing || !event.sourceEvent) return;

            // On brush start, clear interactions
            if (event.type === "start") {
                hideTooltip();
                if (appState.stickyPoint) { // Clear sticky point if user starts a new brush
                    appState.stickyPoint = null;
                    updateSVGStickyHighlight();
                }
            }

            const selection = event.selection; // Pixel range [x0, x1] or null if cleared

            if (!selection) { // Brush was cleared
                // Update state only if a date range filter was previously active
                if (appState.currentFilters.dateRange !== null) {
                    appState.currentFilters.dateRange = null;
                    updateVisualization(); // Update based on removed filter
                }
            } else { // Brush selected a range
                // Convert pixel selection back to date range using the time scale
                const newDateRange = selection.map(appState.scales.time.invert);

                // Update state only if the date range actually changed
                if (!appState.currentFilters.dateRange ||
                    appState.currentFilters.dateRange[0].getTime() !== newDateRange[0].getTime() ||
                    appState.currentFilters.dateRange[1].getTime() !== newDateRange[1].getTime())
                {
                    appState.currentFilters.dateRange = newDateRange;
                    updateVisualization(); // Update based on new filter
                }
            }
        }

        // Handles input changes in the search box
        function handleSearchInput(event) {
            const query = event.target.value;
            // Update only if the query actually changed
            if (appState.currentFilters.searchQuery !== query) {
                appState.currentFilters.searchQuery = query;
                updateVisualization(); // Trigger update with new search filter
            }
        }

        // Handles changes in the Select2 tag dropdown
        function handleTagChange() {
            const selectedTagsArray = $(ELEMENTS.tagSelect.node()).val() || []; // Get array of selected tag values
            const newSelectedTags = new Set(selectedTagsArray); // Convert to Set

            // Update only if the set of selected tags actually changed
            if (appState.currentFilters.selectedTags.size !== newSelectedTags.size ||
                !selectedTagsArray.every(tag => appState.currentFilters.selectedTags.has(tag)))
            {
                appState.currentFilters.selectedTags = newSelectedTags;
                updateVisualization(); // Trigger update with new tag filter
            }
        }

        // Handles changes in the timeline binning dropdown
        function handleBinningChange(event) {
            // Only need to redraw the timeline, as binning doesn't affect filtering or scatterplot directly
            console.log("Binning selection changed, redrawing timeline.");
            drawTimeline();
        }

        // Resets the search filter
        function resetSearch() {
            ELEMENTS.searchInput.property("value", ""); // Clear the input field
            // Update only if a search query was active
            if (appState.currentFilters.searchQuery !== '') {
                appState.currentFilters.searchQuery = '';
                updateVisualization();
            }
        }

        // Resets the tag filter
        function resetTags() {
            // Update only if tags were selected
            if (appState.currentFilters.selectedTags.size > 0) {
                // Use Select2's method to clear the selection and trigger its change event
                $(ELEMENTS.tagSelect.node()).val(null).trigger('change');
                // Note: updateVisualization() is called implicitly by handleTagChange
            }
        }

        // Resets the timeline brush (clears date range filter)
        function resetTimelineBrush() {
            // Update only if a date range filter is active
            if (appState.currentFilters.dateRange !== null) {
                appState.isBrushing = true; // Set flag to prevent feedback loop from .move
                // Programmatically move the brush to null (clears selection)
                ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush.move, null);
                appState.isBrushing = false; // Clear flag
                // Note: The 'end' event from .move(null) should trigger handleBrush, which calls updateVisualization
            }
        }

        // Sets the initial state of the timeline brush (visual only, no filter)
        function setInitialTimelineBrush() {
            const fullRangePixels = appState.scales.time.range(); // Get full pixel range of time scale
            appState.isBrushing = true; // Prevent event feedback loop
            // Move brush visually to cover the full range
            ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush.move, fullRangePixels);
            appState.isBrushing = false; // Clear flag
            // Ensure the actual filter state remains null
            appState.currentFilters.dateRange = null;
            updateFilterSummary(); // Update text to reflect no date filter
        }

        // Handles mouse movement over the scatterplot canvas for hover effects
        function handleCanvasMouseMove(event) {
            const [mouseX, mouseY] = d3.pointer(event); // Get mouse coords relative to canvas
            const transform = appState.currentTransform;

            // Convert mouse coords to *untransformed* data space for quadtree search
            const invertedX = transform.invertX(mouseX);
            const invertedY = transform.invertY(mouseY);

            // Find nearest point in quadtree within a search radius
            // Scale search radius inversely with zoom to maintain constant screen size
            const searchRadius = (CONFIG.highlightRadius + 2) / transform.k; // Add buffer
            const closest = appState.quadtree?.find(invertedX, invertedY, searchRadius); // Use optional chaining

            // Update hover state only if the closest point changed
            if (appState.hoveredPoint?.id !== closest?.id) {
                appState.hoveredPoint = closest;
                updateSVGHoverHighlight(); // Update SVG circle
            }

            // Show/hide tooltip only if no point is currently sticky
            if (!appState.stickyPoint) {
                if (closest) {
                    showTooltip(event, closest); // Show tooltip for the closest point
                } else {
                    hideTooltip(); // Hide if mouse isn't near any point
                }
            }
        }

        // Handles clicks on the scatterplot canvas
        function handleCanvasClick(event) {
            const [mouseX, mouseY] = d3.pointer(event);
            const transform = appState.currentTransform;
            const invertedX = transform.invertX(mouseX);
            const invertedY = transform.invertY(mouseY);
            const clickRadius = (CONFIG.highlightRadius + 3) / transform.k; // Slightly larger click radius?

            // Find the point clicked on
            const clickedPoint = appState.quadtree?.find(invertedX, invertedY, clickRadius);

            if (clickedPoint) { // Clicked on a point
                if (appState.stickyPoint?.id === clickedPoint.id) {
                    // Clicked the *same* sticky point again: unstick it
                    appState.stickyPoint = null;
                    hideTooltip(); // Hide tooltip
                } else {
                    // Clicked a *new* or non-sticky point: make it sticky
                    appState.stickyPoint = clickedPoint;
                    showTooltip(event, clickedPoint); // Show and pin tooltip
                    // Open URL associated with the point in a new tab
                    if (clickedPoint.url) {
                        try { window.open(clickedPoint.url, '_blank'); } catch (e) { console.warn("URL open failed:", clickedPoint.url, e); }
                    }
                }
                // Clear hover state when clicking
                appState.hoveredPoint = null;
                updateSVGHoverHighlight(); // Hide hover circle
                updateSVGStickyHighlight(); // Update sticky circle state

            } else { // Clicked outside any point
                // Clear sticky point if one exists
                if (appState.stickyPoint) {
                    appState.stickyPoint = null;
                    hideTooltip();
                    updateSVGStickyHighlight(); // Hide sticky circle
                }
            }
        }

        // Handles double-clicks on the scatterplot canvas for zoom-to-point
        function handleCanvasDoubleClick(event) {
             const [mouseX, mouseY] = d3.pointer(event);
             const transform = appState.currentTransform;
             const invertedX = transform.invertX(mouseX);
             const invertedY = transform.invertY(mouseY);
             const clickRadius = (CONFIG.highlightRadius + 3) / transform.k;

             // Find the point double-clicked on
             const targetPoint = appState.quadtree?.find(invertedX, invertedY, clickRadius);

             if (targetPoint) { // Found a point
                 const { width, height } = appState.dimensions.scatterplot;
                 // Determine target zoom scale (e.g., zoom in by factor of 2, respecting limits)
                 const targetScale = Math.min(CONFIG.zoomMax, Math.max(CONFIG.zoomMin, transform.k * 2));

                 // Calculate the translation needed to center the target point
                 // Use the pre-calculated untransformed pixel coordinates (px, py)
                 const newTransform = d3.zoomIdentity
                     .translate(width / 2, height / 2) // Move viewport origin to center
                     .scale(targetScale)              // Apply desired zoom scale
                     .translate(-targetPoint.px, -targetPoint.py); // Translate the target point to the origin

                 // Apply the new transform smoothly using a D3 transition
                 ELEMENTS.scatterplotCanvas.transition()
                     .duration(750) // Animation duration
                     .call(appState.behaviors.zoom.transform, newTransform);

                 // Clear interactions during the transition
                 hideTooltip();
                 appState.hoveredPoint = null;
                 appState.stickyPoint = null;
                 updateSVGHoverHighlight();
                 updateSVGStickyHighlight();
             }
         }

        // Handles mouse leaving the scatterplot canvas area
         function handleCanvasMouseOut(event) {
             // Clear hover state
             if (appState.hoveredPoint) {
                 appState.hoveredPoint = null;
                 updateSVGHoverHighlight();
             }
             // Hide tooltip only if it's not sticky
             if (!appState.stickyPoint) {
                 hideTooltip();
             }
         }

        // Handles mouse hovering over a timeline histogram bar
         function handleTimelineBarMouseOver(event, d) { // d is the bin data {x0, x1, ...}
             // Store the date range of the hovered bin
             appState.timelineHoveredBin = { x0: d.x0, x1: d.x1 };
             // Redraw scatterplot to highlight points within this bin's date range
             drawScatterplot();
             // Visually highlight the bar itself
             d3.select(event.currentTarget).style("fill", CONFIG.timelineBarHoverColor);
         }

        // Handles mouse leaving a timeline histogram bar
         function handleTimelineBarMouseOut(event, d) {
             // Clear the hovered bin state
             appState.timelineHoveredBin = null;
             // Redraw scatterplot to remove the timeline hover highlight
             drawScatterplot();
             // Restore the bar's original color
             d3.select(event.currentTarget).style("fill", CONFIG.timelineBarColor);
         }

        // Handles window resize events (debounced)
        function handleResize() {
            console.log("Resize detected...");
            showLoading("Adjusting layout...");

            // 1. Recalculate Dimensions
            setupDimensions();

            // 2. Update Scale Ranges to match new dimensions
            appState.scales.x.range([0, appState.dimensions.scatterplot.width]);
            appState.scales.y.range([appState.dimensions.scatterplot.height, 0]);
            appState.scales.time.range([0, appState.dimensions.timeline.width]);
            appState.scales.count.range([appState.dimensions.timeline.height, 0]);

            // 3. Recalculate untransformed pixel coordinates (px, py) for all points
            //    Crucial for quadtree and potentially drawing performance
            appState.fullData.forEach(d => {
                d.px = appState.scales.x(d.x);
                d.py = appState.scales.y(d.y);
                if (isNaN(d.px) || isNaN(d.py)) { console.warn(`NaN px/py after resize for ID ${d.id}`); }
            });

            // 4. Update Axis Generators (specifically grid tick sizes)
            appState.axes.xGrid.tickSize(-appState.dimensions.scatterplot.height);
            appState.axes.yGrid.tickSize(-appState.dimensions.scatterplot.width);

            // 5. Update SVG/Canvas Element Attributes (size, transforms)
            setupSVGStructure();
            setupCanvas();

            // 6. Update D3 Behavior Constraints (zoom extent, brush extent)
            appState.behaviors.zoom.translateExtent([[0, 0], [appState.dimensions.scatterplot.width, appState.dimensions.scatterplot.height]]).extent([[0, 0], [appState.dimensions.scatterplot.width, appState.dimensions.scatterplot.height]]);
            appState.behaviors.brush.extent([[0, 0], [appState.dimensions.timeline.width, appState.dimensions.timeline.height]]);
            // Re-apply brush behavior AFTER setting new extent
            ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush);

            // 7. Re-apply current brush selection visually
            const currentSelectionPixels = appState.currentFilters.dateRange
                ? appState.currentFilters.dateRange.map(appState.scales.time) // Convert date range back to pixels using NEW scale range
                : appState.scales.time.range(); // If no filter, visually brush full new range
            // Use timeout to ensure DOM is updated before moving brush programmatically
            setTimeout(() => {
                appState.isBrushing = true; // Prevent feedback loop
                ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush.move, currentSelectionPixels);
                appState.isBrushing = false;
            }, 0);

            // 8. Re-apply current zoom transform IMMEDIATELY (no transition)
            ELEMENTS.scatterplotCanvas.call(appState.behaviors.zoom.transform, appState.currentTransform);

            // 9. Perform a full redraw of all components
            //    This re-applies filters (needed for quadtree update) and redraws everything
            updateVisualization();

            console.log("Resize update complete.");
            showLoading(false); // Hide loading indicator
        }

        // --- Tooltip Functions ---
        // Shows the tooltip with appropriate content near the event position
        function showTooltip(event, data) {
            // Use pageX/pageY from the mouse event for positioning relative to viewport
             const pageX = event.pageX;
             const pageY = event.pageY;

            ELEMENTS.tooltip
                .style("display", "inline-block")
                // Position slightly offset from the cursor
                .style("right", `${10 + CONFIG.tooltipOffsetX}px`)
                .style("top", `${10 + CONFIG.tooltipOffsetY}px`)
                // Populate tooltip content
                .html(`
                    <strong>${data.title || 'N/A'}</strong><br>
                    Author: ${data.author || 'N/A'}<br>
                    Date: ${data.date.toLocaleDateString()}<br>
                    Tags: ${data.tags?.length > 0 ? data.tags.join(', ') : 'None'}
                `); // Use optional chaining and check length for tags
        }

        // Hides the tooltip
        function hideTooltip() {
            ELEMENTS.tooltip.style("display", "none");
        }

        // --- UI Feedback Functions ---
        // Shows/hides the loading indicator overlay
        function showLoading(message) {
            if (message) {
                ELEMENTS.loadingIndicator.text(message).style("display", "block");
            } else {
                ELEMENTS.loadingIndicator.style("display", "none");
            }
        }
        // Displays an error message in the dedicated error area
        function displayError(message) {
             ELEMENTS.errorDisplay
                 .text(`Error: ${message}`) // Add "Error: " prefix for clarity
                 .style("display", "block"); // Make the error area visible
        }
        // Updates the text describing the current filter state and data count
        function updateFilterSummary() {
             // Start with the count of currently visible items
             // let base = `Showing ${appState.filteredData.length} articles`;
             const filtersActive = []; // Array to hold descriptions of active filters
             const f = appState.currentFilters; // Shorthand
             const anyFilter = Boolean(f.searchQuery.trim() || f.selectedTags.size > 0 || f.dateRange);
             const count = anyFilter ? appState.filteredData.length : appState.fullData.length;

             let base = `Showing ${count} articles`;

             // Add descriptions for each active filter
             if (f.searchQuery) {
                 filtersActive.push(`matching search "${f.searchQuery}"`);
             }
             if (f.selectedTags.size > 0) {
                 // Join selected tags for display
                 filtersActive.push(`tagged "${Array.from(f.selectedTags).join(', ')}"`);
             }
             if (f.dateRange) {
                 const fmt = d3.timeFormat("%b %d, %Y"); // Format dates nicely
                 const start = fmt(f.dateRange[0]);
                 const end = fmt(f.dateRange[1]);
                 // Check if the range covers less than a full day for "on date" vs "from date to date"
                 if (d3.timeDay.count(f.dateRange[0], f.dateRange[1]) < 1) {
                      filtersActive.push(`from ${start}`); // Use "from" even for single day for consistency with brush
                 } else {
                     filtersActive.push(`from ${start} to ${end}`);
                 }
             }

             // Append filter descriptions if any are active
             if (filtersActive.length > 0) {
                 base += " filtered by: " + filtersActive.join(" and ") + ".";
             } else {
                 // Explicitly state if no filters are applied
                 base += " (all).";
             }

             // Set the text content of the summary element
             ELEMENTS.filterSummary.text(base);
         }


        // --- Utility Function ---
        // Debounces a function call to limit its execution rate
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args); // Call the original function
                };
                clearTimeout(timeout); // Reset timer on each call
                timeout = setTimeout(later, wait); // Set new timer
            };
        }

        // --- Start the application ---
        initialize(); // Call the main initialization function when the script loads

    </script>
</body>
</html>
