<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASPI Strategist Embedding Explorer (Enhanced)</title> <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

    <style>
        /* --- Base Layout and Dark Theme Styles --- */
        :root {
            /* Define CSS variables for dynamic colors */
            --highlight-color: #ffcc00; /* Default active color */
            --deemphasis-color: #c2c3c4; /* Default inactive color */
            --timeline-hover-color: #a13b66; /* Default timeline hover color */
        }

        body {
            margin: 0;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #1e1e1e;
            color: #cccccc;
        }

        #container {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        #controls {
            width: 280px;
            padding: 15px;
            overflow-y: auto;
            border-right: 1px solid #333333;
            flex-shrink: 0;
            background-color: #252526;
        }

        #visualization-area {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        /* --- Scatterplot Area --- */
        #scatterplot-container {
            position: relative;
            flex: 1;
            width: 100%;
            min-height: 0;
        }

        #scatterplot-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #scatterplot-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #scatterplot-svg .axis, #scatterplot-svg .grid {
             pointer-events: auto;
        }

        /* --- Timeline Area --- */
        #timeline-container {
            width: 100%;
            height: 150px;
            border-top: 1px solid #333333;
            flex-shrink: 0;
            background-color: #2d2d2d;
            position: relative;
        }

        #timeline-svg {
            position: absolute;
            top:0; left:0; width: 100%; height: 100%;
        }

        /* --- Tooltip --- */
        #tooltip {
            position: absolute;
            background: rgba(45, 45, 45, 0.95);
            border: 1px solid #555555;
            color: #eeeeee;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            display: none;
            max-width: 350px;
            z-index: 100;
            font-size: 13px;
            line-height: 1.5;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

        /* --- Controls Styling --- */
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #444444;
            position: relative; /* Needed for absolute positioning of autocomplete */
        }
         .control-group:last-child {
             border-bottom: none;
             margin-bottom: 0;
             padding-bottom: 0;
         }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #eeeeee;
        }

        input[type="text"], select {
            background-color: #3c3c3c;
            color: #cccccc;
            border: 1px solid #555555;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        /* --- Autocomplete Suggestions --- */
        #autocomplete-suggestions {
            position: relative;
            background-color: #2d2d2d;
            border: 1px solid #555555;
            border-top: none; /* Attach visually to input */
            border-radius: 0 0 4px 4px;
            width: calc(100% - 2px); /* Match input width minus borders */
            max-height: 50%;
            overflow-y: auto;
            z-index: 50; /* Below tooltip, above other controls */
            display: none; /* Hidden by default */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            left: 1px; /* Align with input accounting for border */
            top: 100%; /* Position below the input */
        }

        .suggestion-item {
            padding: 6px 10px;
            color: #cccccc;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-item:hover, .suggestion-item.active {
            background-color: #555555;
            color: #ffffff;
        }

        /* --- Color Pickers --- */
        .color-picker-container {
            display: flex;
            align-items: center;
            margin-top: 8px;
            justify-content: space-between; /* Space out label and picker */
        }
        .color-picker-container label {
            margin-bottom: 0; /* Remove bottom margin for inline label */
            margin-right: 10px;
            flex-shrink: 0; /* Prevent label from shrinking */
        }
        input[type="color"] {
            width: 50px; /* Adjust size */
            height: 30px;
            border: 1px solid #555555;
            padding: 2px; /* Small padding */
            border-radius: 4px;
            cursor: pointer;
            background-color: #3c3c3c; /* Match other inputs */
        }
        /* Optional: Style the color picker preview */
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px;}
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 3px;}


        /* --- D3 Element Styling --- */
        .brush .selection { fill: #777; fill-opacity: .3; stroke: #fff; }
        .brush .handle { fill: #555; stroke: #fff; }
        .axis text { font-size: 10px; fill: #cccccc; }
        .axis line, .axis path { stroke: #555555; shape-rendering: crispEdges; }
        .grid line { stroke: #444444; stroke-opacity: 0.7; shape-rendering: crispEdges; }
        .grid path { stroke-width: 0; }

        /* Timeline Bars - Fill is now dynamic via JS */
        .timeline-bar:hover {
            /* Use CSS variable for hover color */
            fill: var(--timeline-hover-color);
        }

        /* --- Buttons and Feedback --- */
        button { background-color: #555555; color: #eeeeee; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px; transition: background-color 0.2s ease; }
        button:hover { background-color: #666666; }
        #reset-view-btn { display: block; width: calc(100% - 5px); margin-top: 15px; }

        #filter-summary { margin-top: 15px; font-size: 13px; color: #aaaaaa; line-height: 1.4; }
        #loading-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px 30px; border-radius: 8px; z-index: 200; display: none; font-size: 1.1em;}
        #error-display { color: #f88; margin-top: 10px; padding: 10px; border: 1px solid #f88; border-radius: 4px; background-color: rgba(255,0,0,0.1); display: none; }
        #query-error-display { color: #ffcc66; font-size: 12px; margin-top: 5px; display: none; }

         /* Basic Responsiveness */
        @media (max-width: 768px) {
            #container { flex-direction: column; }
            #controls { width: 100%; max-height: 250px; border-right: none; border-bottom: 1px solid #333333; }
            #visualization-area { flex-grow: 1; }
            #timeline-container { height: 120px; }
        }
    </style>
</head>
<body>
    <div id="loading-indicator">Loading Articles...</div>

    <div id="container">

        <div id="controls">
            <h2>ASPI <em>Strategist</em> Embedding Explorer</h2>
            <p>All <em>Strategist</em> posts up to May 4 2025 are represented as points in an embedding space, in which posts with semantically-similar content appear closer. Try searching for a tag to see how topics form clusters.</p>
            <p>Use <code>tag:</code>, <code>intitle:</code> or <code>author:</code> to specify what you're looking for. Combine search terms with <code>AND</code>, <code>OR</code>, <code>NOT</code>, and parentheses <code>()</code> for grouping. If you're searching for a term with spaces in it, put the whole thing in quotes like this: <code>"nuclear weapons"</code></p>
             <div id="error-display"></div>

            <div class="control-group">
                <label for="query-input">Search Query:</label>
                <input type="text" id="query-input" placeholder="e.g., tag:China AND author:'Alex Bristow'" autocomplete="off"> <div id="autocomplete-suggestions"></div>
                <div id="query-error-display"></div>
                <button id="reset-query-btn">Reset Query</button>
            </div>

            <div class="control-group">
                 <label for="binning-select">Timeline Granularity:</label>
                 <select id="binning-select">
                     <option value="week" selected>Week</option>
                     <option value="month">Month</option>
                     <option value="year">Year</option>
                 </select>
                 <button id="reset-timeline">Reset Date Range</button>
             </div>

             <div class="control-group">
                 <label>Color Settings:</label>
                 <div class="color-picker-container">
                     <label for="active-color-picker">Highlighted Points:</label>
                     <input type="color" id="active-color-picker">
                 </div>
                 <div class="color-picker-container">
                     <label for="inactive-color-picker">Un-highlighted Points:</label>
                     <input type="color" id="inactive-color-picker">
                 </div>
             </div>

             <!--This doesn't work at the moment. Dummied out for now, find a way to fix it later.-->
<!--              <div class="control-group">
                 <label>View Controls:</label>
                 <button id="reset-view-btn">Reset Scatterplot View</button>
             </div> -->

             <div id="filter-summary"></div>
        </div>

        <div id="visualization-area">
            <div id="scatterplot-container">
                <canvas id="scatterplot-canvas"></canvas>
                <svg id="scatterplot-svg">
                    <g class="scatterplot-content">
                        <g class="grid x-grid"></g> <g class="grid y-grid"></g>
                        <g class="axis x-axis"></g> <g class="axis y-axis"></g>
                        <circle class="hover-highlight" r="6" fill="none" stroke="#00ffff" stroke-width="1.5" pointer-events="none" display="none"></circle>
                        <circle class="sticky-highlight" r="6" fill="none" stroke="#ffcc00" stroke-width="1.5" pointer-events="none" display="none"></circle>
                    </g>
                </svg>
            </div>
            <div id="timeline-container">
                <svg id="timeline-svg">
                     <g class="timeline-content">
                         <g class="timeline-bars"></g>
                         <g class="axis time-axis"></g>
                         <g class="brush"></g>
                     </g>
                </svg>
            </div>
            <div id="tooltip"></div>
        </div>
    </div>

    <script type="module">

        // --- Configuration Constants ---
        const CONFIG = {
            dataUrl: 'articles.json',
            scatterplotMargin: { top: 20, right: 20, bottom: 40, left: 50 },
            timelineMargin: { top: 10, right: 20, bottom: 30, left: 50 },
            pointRadius: 3,
            highlightRadius: 5,
            // Default colors moved to appState.colors
            hoverHighlightColor: '#00ffff', // Stroke for hover SVG circle
            stickyHighlightColor: '#ffcc00', // Stroke for sticky SVG circle
            timelineBarHoverColor: '#a13b66', // Fill for timeline bar on hover (distinct)
            zoomMin: 0.5,
            zoomMax: 20,
            debounceTime: 350,
            tooltipOffsetX: 0,
            tooltipOffsetY: 0,
            autocompleteLimit: 25 // Max suggestions to show
        };

        // --- Application State ---
        const appState = {
            fullData: [],
            filteredData: [], // Points matching BOTH date range AND query function
            uniqueTags: new Set(),    // Added for autocomplete
            uniqueAuthors: new Set(), // Added for autocomplete
            sortedUniqueTags: [],     // Sorted array version
            sortedUniqueAuthors: [],  // Sorted array version

            // Dynamic colors, initialized with defaults
            colors: {
                active: '#ffcc00',   // Default active color
                inactive: '#c2c3c4', // Default inactive color
            },

            currentFilters: {
                dateRange: null,
                rawQuery: '',
                queryFunction: () => true,
                queryError: null
            },

            // Autocomplete state
            autocomplete: {
                active: false,
                prefix: null, // 'tag' or 'author'
                term: '',     // Partial term being typed
                suggestions: [],
                selectedIndex: -1 // For keyboard navigation
            },

            currentTransform: d3.zoomIdentity,
            dimensions: { scatterplot: { width: 0, height: 0 }, timeline: { width: 0, height: 0 } },
            scales: { x: null, y: null, time: null, count: null },
            axes: { x: null, y: null, time: null, xGrid: null, yGrid: null },
            behaviors: { zoom: null, brush: null },
            quadtree: null,
            hoveredPoint: null,
            stickyPoint: null,
            timelineHoveredBin: null,
            isBrushing: false,
            canvasContext: null
        };

        // --- DOM Element Selectors ---
        const ELEMENTS = {
            loadingIndicator: d3.select("#loading-indicator"),
            errorDisplay: d3.select("#error-display"),
            queryErrorDisplay: d3.select("#query-error-display"),
            controls: d3.select("#controls"),
            queryInput: d3.select("#query-input"),
            autocompleteSuggestions: d3.select("#autocomplete-suggestions"), // Added
            activeColorPicker: d3.select("#active-color-picker"),       // Added
            inactiveColorPicker: d3.select("#inactive-color-picker"),   // Added
            binningSelect: d3.select("#binning-select"),
            resetQueryBtn: d3.select("#reset-query-btn"),
            resetTimelineBtn: d3.select("#reset-timeline"),
            resetViewBtn: d3.select("#reset-view-btn"),
            filterSummary: d3.select("#filter-summary"),
            scatterplotContainer: d3.select("#scatterplot-container"),
            scatterplotCanvas: d3.select("#scatterplot-canvas"),
            scatterplotSvg: d3.select("#scatterplot-svg"),
            scatterplotContent: d3.select("#scatterplot-svg g.scatterplot-content"),
            xAxisGroup: d3.select("#scatterplot-svg g.x-axis"), yAxisGroup: d3.select("#scatterplot-svg g.y-axis"),
            xGridGroup: d3.select("#scatterplot-svg g.x-grid"), yGridGroup: d3.select("#scatterplot-svg g.y-grid"),
            hoverHighlight: d3.select("#scatterplot-svg .hover-highlight"), stickyHighlight: d3.select("#scatterplot-svg .sticky-highlight"),
            timelineContainer: d3.select("#timeline-container"), timelineSvg: d3.select("#timeline-svg"),
            timelineContent: d3.select("#timeline-svg g.timeline-content"),
            timelineBarsGroup: d3.select("#timeline-svg g.timeline-bars"), timeAxisGroup: d3.select("#timeline-svg g.time-axis"),
            timelineBrushGroup: d3.select("#timeline-svg g.brush"), tooltip: d3.select("#tooltip")
        };

        // --- Main Initialization Function ---
        async function initialize() {
            showLoading("Loading data...");
            ELEMENTS.errorDisplay.style('display', 'none');
            ELEMENTS.queryErrorDisplay.style('display', 'none');
            try {
                // 1. Load Data
                const rawData = await d3.json(CONFIG.dataUrl);
                if (!rawData || !Array.isArray(rawData)) { throw new Error(`Invalid data format.`); }

                // 2. Process Data (now collects unique tags/authors)
                processData(rawData);
                if (appState.fullData.length === 0) { throw new Error("No valid data points found."); }

                // 3. Setup UI and Visualization Components
                setupDimensions();
                setupScales();
                setupAxes();
                setupSVGStructure();
                setupCanvas();
                setupColorPickers(); // Initialize color pickers
                setupInteractions(); // Includes listeners for query input, color pickers etc.

                // 4. Initial Render
                updateVisualization(true);
                setInitialTimelineBrush();

                console.log("Initialization complete.");
                showLoading(false);
            } catch (error) {
                console.error("Initialization failed:", error);
                showLoading(false);
                displayError(`Initialization failed: ${error.message}`);
            }
        }

        // --- Data Handling ---
        function processData(rawData) {
            const uniqueTags = new Set();
            const uniqueAuthors = new Set();

            appState.fullData = rawData.map((d, i) => {
                // ... (validation as before) ...
                if (typeof d !== 'object' || d === null) return null;
                const date = new Date(d.date);
                if (isNaN(date.getTime())) return null;
                const xVal = +d.x; const yVal = +d.y;
                if (d.x == null || d.y == null || isNaN(xVal) || isNaN(yVal)) return null;

                const title = d.title || '';
                const author = d.author || 'Unknown';
                const tags = Array.isArray(d.tags) ? d.tags.map(String).filter(Boolean) : [];

                // Add to unique sets (use original case for display, lowercase for search)
                tags.forEach(tag => uniqueTags.add(tag));
                if (author !== 'Unknown') { uniqueAuthors.add(author); }

                return {
                    id: d.id || i, title: title, author: author, url: d.url, date: date, tags: tags,
                    x: xVal, y: yVal, px: 0, py: 0,
                    _titleLower: title.toLowerCase(),
                    _authorLower: author.toLowerCase(),
                    _tagsLower: tags.map(t => t.toLowerCase())
                };
            }).filter(Boolean);

            // Store unique sets and sorted arrays in appState
            appState.uniqueTags = uniqueTags;
            appState.uniqueAuthors = uniqueAuthors;
            appState.sortedUniqueTags = Array.from(uniqueTags).sort((a, b) => a.localeCompare(b));
            appState.sortedUniqueAuthors = Array.from(uniqueAuthors).sort((a, b) => a.localeCompare(b));

            console.log(`Processed ${appState.fullData.length} articles. Found ${uniqueTags.size} tags, ${uniqueAuthors.size} authors.`);
        }


        // --- Query Parsing and Evaluation (Largely unchanged) ---
        const TOKEN_TYPES = { 
            TERM: 'TERM', PREFIX_TAG: 'PREFIX_TAG', PREFIX_AUTHOR: 'PREFIX_AUTHOR', PREFIX_INTITLE: 'PREFIX_INTITLE',
            AND: 'AND', OR: 'OR', NOT: 'NOT', LPAREN: 'LPAREN', RPAREN: 'RPAREN', EOF: 'EOF'
        };
        function tokenizeQuery(query) { 
            const tokens = []; let pos = 0; query = query.trim();
            const patterns = [ { type: TOKEN_TYPES.LPAREN, regex: /^\(/ }, { type: TOKEN_TYPES.RPAREN, regex: /^\)/ }, { type: TOKEN_TYPES.AND, regex: /^\bAND\b/i }, { type: TOKEN_TYPES.OR, regex: /^\bOR\b/i }, { type: TOKEN_TYPES.NOT, regex: /^\bNOT\b/i }, { type: TOKEN_TYPES.PREFIX_TAG, regex: /^\bTAG:/i }, { type: TOKEN_TYPES.PREFIX_AUTHOR, regex: /^\bAUTHOR:/i }, { type: TOKEN_TYPES.PREFIX_INTITLE, regex: /^\bINTITLE:/i }, { type: TOKEN_TYPES.TERM, regex: /^"([^"]*)"/ }, { type: TOKEN_TYPES.TERM, regex: /^([^\s()]+)/ } ];
            while (pos < query.length) {
                let matched = false; const whitespaceMatch = query.substring(pos).match(/^\s+/); if (whitespaceMatch) { pos += whitespaceMatch[0].length; continue; }
                for (const pattern of patterns) {
                    const match = query.substring(pos).match(pattern.regex);
                    if (match) { let value = match[0]; if (pattern.type === TOKEN_TYPES.TERM && match[1] !== undefined) { value = match[1]; } tokens.push({ type: pattern.type, value: value.toLowerCase() }); pos += match[0].length; matched = true; break; }
                }
                if (!matched) { throw new Error(`Invalid char at pos ${pos}: "${query.substring(pos, pos + 10)}..."`); }
            }
            tokens.push({ type: TOKEN_TYPES.EOF, value: null }); return tokens;
         }
        let currentTokens = []; let currentTokenIndex = 0;
        function currentToken() { return currentTokens[currentTokenIndex]; }
        function nextToken() { if (currentTokenIndex < currentTokens.length - 1) currentTokenIndex++; }
        function matchToken(type) { if (currentToken().type === type) { const token = currentToken(); nextToken(); return token; } throw new Error(`Syntax Error: Expected ${type} found ${currentToken().type}`); }
        function parseExpression() { let leftFilter = parseTerm(); while (currentToken().type === TOKEN_TYPES.OR) { nextToken(); const rightFilter = parseTerm(); const capturedLeft = leftFilter; leftFilter = (d) => capturedLeft(d) || rightFilter(d); } return leftFilter; }
        function parseTerm() { let leftFilter = parseFactor(); while (currentToken().type === TOKEN_TYPES.AND) { nextToken(); const rightFilter = parseFactor(); const capturedLeft = leftFilter; leftFilter = (d) => capturedLeft(d) && rightFilter(d); } return leftFilter; }
        function parseFactor() { if (currentToken().type === TOKEN_TYPES.NOT) { nextToken(); const filterToNegate = parseFactor(); return (d) => !filterToNegate(d); } else if (currentToken().type === TOKEN_TYPES.LPAREN) { nextToken(); const expressionFilter = parseExpression(); matchToken(TOKEN_TYPES.RPAREN); return expressionFilter; } else { return parseAtom(); } }
        function parseAtom() { const token = currentToken(); let filterFunc = () => false; switch (token.type) { case TOKEN_TYPES.PREFIX_TAG: nextToken(); const tagTerm = matchToken(TOKEN_TYPES.TERM).value; filterFunc = (d) => d._tagsLower.includes(tagTerm); break; case TOKEN_TYPES.PREFIX_AUTHOR: nextToken(); const authorTerm = matchToken(TOKEN_TYPES.TERM).value; filterFunc = (d) => d._authorLower.includes(authorTerm); break; case TOKEN_TYPES.PREFIX_INTITLE: nextToken(); const titleTerm = matchToken(TOKEN_TYPES.TERM).value; filterFunc = (d) => d._titleLower.includes(titleTerm); break; case TOKEN_TYPES.TERM: nextToken(); const genericTerm = token.value; filterFunc = (d) => d._titleLower.includes(genericTerm) || d._authorLower.includes(genericTerm) || d._tagsLower.includes(genericTerm); break; default: throw new Error(`Syntax Error: Unexpected token ${token.type}`); } return filterFunc; }
        function parseQuery(query) { if (!query || query.trim() === '') { return { queryFunction: () => true, error: null }; } try { currentTokens = tokenizeQuery(query); currentTokenIndex = 0; const queryFunction = parseExpression(); if (currentToken().type !== TOKEN_TYPES.EOF) { throw new Error(`Syntax Error: Unexpected token '${currentToken().value}'`); } return { queryFunction, error: null }; } catch (error) { console.error("Query parsing error:", error); return { queryFunction: () => false, error: error.message }; } }

        // --- Filter Logic (Unchanged) ---
        function isPointFiltered(d) { const { dateRange, queryFunction } = appState.currentFilters; const meetsDate = !dateRange || (d.date >= dateRange[0] && d.date <= dateRange[1]); if (!meetsDate) return false; const meetsQuery = queryFunction(d); if (!meetsQuery) return false; return true; }
        function applyFiltersAndUpdateQuadtree() { appState.filteredData = appState.fullData.filter(isPointFiltered); updateQuadtree(); }
        function updateQuadtree() { if (appState.fullData.length > 0 && appState.fullData[0].px === 0 && appState.fullData[0].py === 0 && appState.scales.x) { appState.fullData.forEach(d => { d.px = appState.scales.x(d.x); d.py = appState.scales.y(d.y); }); } appState.quadtree = d3.quadtree().x(d => d.px).y(d => d.py).addAll(appState.filteredData); }

        // --- UI Setup ---
        function setupDimensions() { 
            const scRect = ELEMENTS.scatterplotContainer.node().getBoundingClientRect(); const tlRect = ELEMENTS.timelineContainer.node().getBoundingClientRect();
            appState.dimensions.scatterplot.width = Math.max(10, scRect.width - CONFIG.scatterplotMargin.left - CONFIG.scatterplotMargin.right); appState.dimensions.scatterplot.height = Math.max(10, scRect.height - CONFIG.scatterplotMargin.top - CONFIG.scatterplotMargin.bottom);
            appState.dimensions.timeline.width = Math.max(10, tlRect.width - CONFIG.timelineMargin.left - CONFIG.timelineMargin.right); appState.dimensions.timeline.height = Math.max(10, tlRect.height - CONFIG.timelineMargin.top - CONFIG.timelineMargin.bottom);
        }
        function setupScales() { 
            const scDims = appState.dimensions.scatterplot; const tlDims = appState.dimensions.timeline; const xExt = d3.extent(appState.fullData, d => d.x); const yExt = d3.extent(appState.fullData, d => d.y); const dateExt = d3.extent(appState.fullData, d => d.date); if (xExt[0] === undefined || yExt[0] === undefined || !dateExt[0]) { throw new Error("Invalid data extents."); }
            appState.scales.x = d3.scaleLinear().domain(xExt).nice().range([0, scDims.width]); appState.scales.y = d3.scaleLinear().domain(yExt).nice().range([scDims.height, 0]); appState.scales.time = d3.scaleTime().domain(dateExt).nice().range([0, tlDims.width]); appState.scales.count = d3.scaleLinear().range([tlDims.height, 0]);
            if (!appState.scales.x || !appState.scales.y) { throw new Error("Scatterplot scales failed init."); } appState.fullData.forEach(d => { d.px = appState.scales.x(d.x); d.py = appState.scales.y(d.y); });
        }
        function setupAxes() { 
            if (!appState.scales.x || !appState.scales.y || !appState.scales.time) { throw new Error("Scales not initialized for axes."); } appState.axes.x = d3.axisBottom(appState.scales.x).ticks(10).tickSizeOuter(0); appState.axes.y = d3.axisLeft(appState.scales.y).ticks(10).tickSizeOuter(0); appState.axes.time = d3.axisBottom(appState.scales.time).ticks(5).tickSizeOuter(0); appState.axes.xGrid = d3.axisBottom(appState.scales.x).tickSize(-appState.dimensions.scatterplot.height).tickFormat(""); appState.axes.yGrid = d3.axisLeft(appState.scales.y).tickSize(-appState.dimensions.scatterplot.width).tickFormat("");
        }
        function setupSVGStructure() { 
            const scM = CONFIG.scatterplotMargin; const tlM = CONFIG.timelineMargin; const scD = appState.dimensions.scatterplot; const tlD = appState.dimensions.timeline; ELEMENTS.scatterplotSvg.attr("width", scD.width + scM.left + scM.right).attr("height", scD.height + scM.top + scM.bottom); ELEMENTS.timelineSvg.attr("width", tlD.width + tlM.left + tlM.right).attr("height", tlD.height + tlM.top + tlM.bottom); ELEMENTS.scatterplotContent.attr("transform", `translate(${scM.left},${scM.top})`); ELEMENTS.timelineContent.attr("transform", `translate(${tlM.left},${tlM.top})`); ELEMENTS.xAxisGroup.attr("transform", `translate(0,${scD.height})`); ELEMENTS.xGridGroup.attr("transform", `translate(0,${scD.height})`); ELEMENTS.timeAxisGroup.attr("transform", `translate(0,${tlD.height})`);
        }
        function setupCanvas() { 
            const scD = appState.dimensions.scatterplot; const scM = CONFIG.scatterplotMargin; ELEMENTS.scatterplotCanvas.attr("width", scD.width).attr("height", scD.height).style("transform", `translate(${scM.left}px, ${scM.top}px)`); appState.canvasContext = ELEMENTS.scatterplotCanvas.node().getContext("2d"); if (!appState.canvasContext) { throw new Error("Failed to get 2D canvas context."); }
        }

        // Initialize color pickers with current colors
        function setupColorPickers() {
            ELEMENTS.activeColorPicker
                .property('value', appState.colors.active)
                .on('input', handleActiveColorChange); // Use 'input' for live updates

            ELEMENTS.inactiveColorPicker
                .property('value', appState.colors.inactive)
                .on('input', handleInactiveColorChange);
        }

        function setupInteractions() {
            const scD = appState.dimensions.scatterplot; const tlD = appState.dimensions.timeline;

            // Zoom/Brush setup (as before)
            appState.behaviors.zoom = d3.zoom().scaleExtent([CONFIG.zoomMin, CONFIG.zoomMax]).translateExtent([[0, 0], [scD.width, scD.height]]).extent([[0, 0], [scD.width, scD.height]]).on("zoom", handleZoom);
            ELEMENTS.scatterplotCanvas.call(appState.behaviors.zoom);
            appState.behaviors.brush = d3.brushX().extent([[0, 0], [tlD.width, tlD.height]]).on("start brush end", handleBrush);
            ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush);

            // --- Control Panel Listeners ---
            // Query input handles regular input and autocomplete logic
            ELEMENTS.queryInput
                .on("input", debounce(handleQueryInput, CONFIG.debounceTime))
                .on("keydown", handleQueryKeyDown) // For Esc, Enter, Arrow keys in autocomplete
                .on("blur", handleQueryBlur); // Hide autocomplete on blur

            // Autocomplete suggestion clicks (using event delegation)
            ELEMENTS.autocompleteSuggestions.on("mousedown", handleSuggestionClick); // Use mousedown to fire before blur

            // Other controls
            ELEMENTS.binningSelect.on("change", handleBinningChange);
            ELEMENTS.resetQueryBtn.on("click", resetQuery);
            ELEMENTS.resetTimelineBtn.on("click", resetTimelineBrush);
            ELEMENTS.resetViewBtn.on("click", handleResetView);
            // Color picker listeners are added in setupColorPickers

            // Canvas interactions (as before)
            ELEMENTS.scatterplotCanvas.on("mousemove", handleCanvasMouseMove).on("click", handleCanvasClick).on("mouseout", handleCanvasMouseOut).on("dblclick.zoom", null).on("dblclick", handleCanvasDoubleClick);
            d3.select(window).on("resize", debounce(handleResize, CONFIG.debounceTime));
        }


        // --- Drawing Functions ---

        // Updated drawScatterplot with 2-pass rendering
        function drawScatterplot() {
            const ctx = appState.canvasContext;
            if (!ctx) return;
            const { width, height } = appState.dimensions.scatterplot;
            const transform = appState.currentTransform;
            const timelineHoverBin = appState.timelineHoveredBin;
            const activeColor = appState.colors.active; // Use dynamic color
            const inactiveColor = appState.colors.inactive; // Use dynamic color

            ctx.save();
            ctx.clearRect(0, 0, width, height);
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.k, transform.k);

            const inactiveRadius = CONFIG.pointRadius / transform.k;
            const activeRadius = CONFIG.highlightRadius / transform.k;

            // --- Pass 1: Draw Inactive Points ---
            ctx.fillStyle = inactiveColor;
            appState.fullData.forEach(d => {
                if (!isPointFiltered(d)) { // Draw only if NOT matching filters
                    ctx.beginPath();
                    ctx.arc(d.px, d.py, inactiveRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // --- Pass 2: Draw Active Points ---
            appState.fullData.forEach(d => {
                if (isPointFiltered(d)) { // Draw only if matching filters
                    let color = activeColor;
                    // Check for timeline hover override
                    if (timelineHoverBin && d.date >= timelineHoverBin.x0 && d.date < timelineHoverBin.x1) {
                        color = CONFIG.timelineBarHoverColor; // Use specific timeline hover color
                    }
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(d.px, d.py, activeRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            ctx.restore();

            // Update SVG highlights (only apply to points in filteredData)
            updateSVGHoverHighlight();
            updateSVGStickyHighlight();
        }

        // Updated drawTimeline to use dynamic active color
        function drawTimeline() {
            const { time: timeScale, count: countScale } = appState.scales;
            if (!appState.dimensions.timeline) return;
            const { width, height } = appState.dimensions.timeline;
            const selectedBinKey = ELEMENTS.binningSelect.property("value");
            const binMap = { 'week': d3.timeWeek, 'month': d3.timeMonth, 'year': d3.timeYear };
            const binningInterval = binMap[selectedBinKey] || d3.timeWeek;
            const timeDomain = timeScale.domain();
            const activeColor = appState.colors.active; // Get current active color

            if (!timeScale || !countScale || !binningInterval || width <= 0 || height <= 0 || !timeDomain || timeDomain.length !== 2) { return; }

            let bins = [];
            try {
                const thresholds = binningInterval.range(timeDomain[0], timeDomain[1]);
                if (!Array.isArray(thresholds)) { throw new Error(`Binning interval range failed.`); }
                const histogram = d3.histogram().value(d => d.date).domain(timeDomain).thresholds(thresholds);
                bins = histogram(appState.filteredData); // Bins based on filtered data
            } catch (error) {
                console.error("Error calculating histogram bins:", error); displayError(`Timeline error: ${error.message}`); return;
            }

            countScale.domain([0, Math.max(1, d3.max(bins, d => d.length) || 0)]).nice();

            ELEMENTS.timelineBarsGroup.selectAll(".timeline-bar")
                .data(bins)
                .join("rect")
                .attr("class", "timeline-bar")
                .attr("x", d => timeScale(d.x0) + 1)
                .attr("width", d => Math.max(0, timeScale(d.x1) - timeScale(d.x0) - 1))
                .attr("y", d => countScale(d.length))
                .attr("height", d => Math.max(0, height - countScale(d.length)))
                .style("fill", activeColor) // Use dynamic active color for bars
                .on("mouseover", handleTimelineBarMouseOver)
                .on("mouseout", handleTimelineBarMouseOut);

             if (appState.axes.time) { ELEMENTS.timeAxisGroup.call(appState.axes.time); }
        }

         function drawAxes() { 
            const { x: scaleX, y: scaleY } = appState.scales; const transform = appState.currentTransform; if (!appState.axes.x || !appState.axes.y || !appState.axes.time || !scaleX || !scaleY) return; const currentXScale = transform.rescaleX(scaleX); const currentYScale = transform.rescaleY(scaleY); ELEMENTS.xAxisGroup.call(appState.axes.x.scale(currentXScale)); ELEMENTS.yAxisGroup.call(appState.axes.y.scale(currentYScale)); ELEMENTS.xGridGroup.call(appState.axes.xGrid.scale(currentXScale)); ELEMENTS.yGridGroup.call(appState.axes.yGrid.scale(currentYScale)); ELEMENTS.timeAxisGroup.call(appState.axes.time);
        }

        // --- Update Functions ---
        function updateVisualization(isInitialLoad = false) {
            applyFiltersAndUpdateQuadtree();
            drawAxes();
            drawTimeline();
            drawScatterplot();
            updateFilterSummary();
        }
         function updateSVGHoverHighlight() { 
             const point = appState.hoveredPoint; const transform = appState.currentTransform; if (point && isPointFiltered(point) && point.id !== appState.stickyPoint?.id) { const cx = transform.applyX(point.px); const cy = transform.applyY(point.py); ELEMENTS.hoverHighlight.attr("cx", cx).attr("cy", cy).style("display", "block"); } else { ELEMENTS.hoverHighlight.style("display", "none"); }
         }
         function updateSVGStickyHighlight() { 
             const point = appState.stickyPoint; const transform = appState.currentTransform; if (point && isPointFiltered(point)) { const cx = transform.applyX(point.px); const cy = transform.applyY(point.py); ELEMENTS.stickyHighlight.attr("cx", cx).attr("cy", cy).style("display", "block"); } else { ELEMENTS.stickyHighlight.style("display", "none"); }
         }

        // --- Autocomplete Functions ---

        // Updates and shows/hides the autocomplete suggestion list
        function updateAutocompleteSuggestions() {
            const { active, suggestions, selectedIndex } = appState.autocomplete;
            const container = ELEMENTS.autocompleteSuggestions;

            if (!active || suggestions.length === 0) {
                container.style('display', 'none');
                return;
            }

            container
                .style('display', 'block')
                .selectAll('.suggestion-item')
                .data(suggestions, d => d) // Use suggestion text as key
                .join('div')
                .attr('class', (d, i) => `suggestion-item${i === selectedIndex ? ' active' : ''}`)
                .text(d => d) // Display the suggestion text
                .attr('title', d => d); // Add title for long suggestions
        }

        // Hides the autocomplete list
        function hideAutocomplete() {
            appState.autocomplete.active = false;
            appState.autocomplete.selectedIndex = -1;
            ELEMENTS.autocompleteSuggestions.style('display', 'none');
        }

        // Completes the query input with the selected suggestion
        function applyAutocompleteSuggestion(suggestion) {
            const input = ELEMENTS.queryInput.node();
            const currentQuery = input.value;
            const prefix = appState.autocomplete.prefix + ':'; // e.g., "tag:"

            // Find the start of the prefix being autocompleted
            const prefixIndex = currentQuery.toLowerCase().lastIndexOf(prefix.toLowerCase());
            if (prefixIndex === -1) { // Should not happen if autocomplete is active
                hideAutocomplete();
                return;
            }

            // Construct the new query: text before prefix + prefix + suggestion + space
            const textBefore = currentQuery.substring(0, prefixIndex);
            // Add quotes if suggestion contains spaces
            const formattedSuggestion = suggestion.includes(' ') ? `"${suggestion}"` : suggestion;
            const newQuery = textBefore + prefix + formattedSuggestion + ' ';

            // Update input value and trigger filter update
            ELEMENTS.queryInput.property('value', newQuery);
            input.focus(); // Keep focus on input
            hideAutocomplete();
            handleQueryInput({ target: input }); // Trigger update manually
        }


        // --- Event Handlers ---

        function handleZoom(event) { 
            if (!event.sourceEvent) return; appState.currentTransform = event.transform; drawAxes(); drawScatterplot(); hideTooltip(); updateSVGHoverHighlight(); updateSVGStickyHighlight();
        }
        function handleBrush(event) { 
            if (appState.isBrushing || !event.sourceEvent) return; if (event.type === "start") { hideTooltip(); if (appState.stickyPoint) { appState.stickyPoint = null; updateSVGStickyHighlight(); } } const selection = event.selection; const newDateRange = selection ? selection.map(appState.scales.time.invert) : null; const oldStart = appState.currentFilters.dateRange?.[0]?.getTime(); const oldEnd = appState.currentFilters.dateRange?.[1]?.getTime(); const newStart = newDateRange?.[0]?.getTime(); const newEnd = newDateRange?.[1]?.getTime(); if (oldStart !== newStart || oldEnd !== newEnd) { appState.currentFilters.dateRange = newDateRange; updateVisualization(); }
        }

        // Updated query input handler for autocomplete
        function handleQueryInput(event) {
            const query = event.target.value;
            appState.currentFilters.rawQuery = query;

            // --- Autocomplete Logic ---
            const cursorPos = event.target.selectionStart || query.length;
            const textBeforeCursor = query.substring(0, cursorPos);
            const tagMatch = textBeforeCursor.match(/\btag:([^\s()]*)$/i);
            const authorMatch = textBeforeCursor.match(/\bauthor:([^\s()]*)$/i);

            let showAutocomplete = false;
            if (tagMatch) {
                appState.autocomplete.prefix = 'tag';
                appState.autocomplete.term = tagMatch[1].toLowerCase(); // Term being typed
                const source = appState.sortedUniqueTags;
                appState.autocomplete.suggestions = source
                    .filter(t => t.toLowerCase().includes(appState.autocomplete.term))
                    .slice(0, CONFIG.autocompleteLimit);
                showAutocomplete = true;
            } else if (authorMatch) {
                appState.autocomplete.prefix = 'author';
                appState.autocomplete.term = authorMatch[1].toLowerCase();
                const source = appState.sortedUniqueAuthors;
                appState.autocomplete.suggestions = source
                    .filter(a => a.toLowerCase().includes(appState.autocomplete.term))
                    .slice(0, CONFIG.autocompleteLimit);
                showAutocomplete = true;
            }

            if (showAutocomplete && appState.autocomplete.suggestions.length > 0) {
                appState.autocomplete.active = true;
                appState.autocomplete.selectedIndex = -1; // Reset selection
                updateAutocompleteSuggestions();
            } else {
                hideAutocomplete();
            }

            // --- Parsing and Filtering Logic (as before) ---
            const { queryFunction, error } = parseQuery(query);
            appState.currentFilters.queryFunction = queryFunction;
            appState.currentFilters.queryError = error;
            if (error) { ELEMENTS.queryErrorDisplay.text(`Syntax Error: ${error}`).style("display", "block"); }
            else { ELEMENTS.queryErrorDisplay.style("display", "none"); }

            updateVisualization();
        }

        // Handle keyboard navigation and selection in autocomplete
        function handleQueryKeyDown(event) {
            const { active, suggestions, selectedIndex } = appState.autocomplete;
            if (!active || suggestions.length === 0) return; // Do nothing if autocomplete isn't active

            switch (event.key) {
                case 'ArrowDown':
                    event.preventDefault(); // Prevent cursor move
                    appState.autocomplete.selectedIndex = (selectedIndex + 1) % suggestions.length;
                    updateAutocompleteSuggestions();
                    break;
                case 'ArrowUp':
                    event.preventDefault(); // Prevent cursor move
                    appState.autocomplete.selectedIndex = (selectedIndex - 1 + suggestions.length) % suggestions.length;
                    updateAutocompleteSuggestions();
                    break;
                case 'Enter':
                case 'Tab': // Also accept Tab for selection
                    if (selectedIndex !== -1) {
                        event.preventDefault(); // Prevent form submission or focus change
                        applyAutocompleteSuggestion(suggestions[selectedIndex]);
                    } else {
                        hideAutocomplete(); // Hide if nothing selected
                    }
                    break;
                case 'Escape':
                    event.preventDefault();
                    hideAutocomplete();
                    break;
            }
        }

        // Hide autocomplete when input loses focus
        function handleQueryBlur(event) {
            // Delay hiding slightly to allow clicks on suggestions to register
            setTimeout(hideAutocomplete, 150);
        }

        // Handle clicks on suggestion items (using event delegation)
        function handleSuggestionClick(event) {
            if (event.target && event.target.classList.contains('suggestion-item')) {
                const suggestionText = event.target.textContent;
                applyAutocompleteSuggestion(suggestionText);
            }
        }


        function handleBinningChange(event) { drawTimeline(); }
        function resetQuery() { ELEMENTS.queryInput.property("value", ""); if (appState.currentFilters.rawQuery !== '' || appState.currentFilters.queryError) { appState.currentFilters.rawQuery = ''; appState.currentFilters.queryFunction = () => true; appState.currentFilters.queryError = null; ELEMENTS.queryErrorDisplay.style("display", "none"); hideAutocomplete(); updateVisualization(); } }
        function resetTimelineBrush() { if (appState.currentFilters.dateRange !== null) { appState.isBrushing = true; ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush.move, null); appState.isBrushing = false; } }
        function setInitialTimelineBrush() { const fullRangePixels = appState.scales.time.range(); appState.isBrushing = true; ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush.move, fullRangePixels); appState.isBrushing = false; appState.currentFilters.dateRange = null; updateFilterSummary(); }
        function handleResetView() { hideTooltip(); appState.hoveredPoint = null; appState.stickyPoint = null; updateSVGHoverHighlight(); updateSVGStickyHighlight(); ELEMENTS.scatterplotCanvas.transition().duration(750).call(appState.behaviors.zoom.transform, d3.zoomIdentity); }

        // --- Color Picker Handlers ---
        function handleActiveColorChange(event) {
            appState.colors.active = event.target.value;
            // Update CSS variable for timeline hover if needed, or rely on JS redraw
            // Redraw relevant parts
            drawScatterplot();
            drawTimeline();
        }
        function handleInactiveColorChange(event) {
            appState.colors.inactive = event.target.value;
            drawScatterplot(); // Only scatterplot uses inactive color
        }

        // --- Canvas Interaction Handlers (Largely unchanged, rely on isPointFiltered) ---
        function handleCanvasMouseMove(event) { 
            const [mouseX, mouseY] = d3.pointer(event); const transform = appState.currentTransform; const invertedX = transform.invertX(mouseX); const invertedY = transform.invertY(mouseY); const searchRadius = (CONFIG.highlightRadius + 2) / transform.k; const closest = appState.quadtree?.find(invertedX, invertedY, searchRadius); if (appState.hoveredPoint?.id !== closest?.id) { appState.hoveredPoint = closest; updateSVGHoverHighlight(); } if (!appState.stickyPoint) { if (closest) { showTooltip(event, closest); } else { hideTooltip(); } }
        }
        function handleCanvasClick(event) { 
            const [mouseX, mouseY] = d3.pointer(event); const transform = appState.currentTransform; const invertedX = transform.invertX(mouseX); const invertedY = transform.invertY(mouseY); const clickRadius = (CONFIG.highlightRadius + 3) / transform.k; const clickedPoint = appState.quadtree?.find(invertedX, invertedY, clickRadius); if (clickedPoint) { if (appState.stickyPoint?.id === clickedPoint.id) { appState.stickyPoint = null; hideTooltip(); } else { appState.stickyPoint = clickedPoint; showTooltip(event, clickedPoint); if (clickedPoint.url) { try { window.open(clickedPoint.url, '_blank'); } catch (e) { console.warn("URL open failed:", e); } } } appState.hoveredPoint = null; updateSVGHoverHighlight(); updateSVGStickyHighlight(); } else { if (appState.stickyPoint) { appState.stickyPoint = null; hideTooltip(); updateSVGStickyHighlight(); } }
        }
        function handleCanvasDoubleClick(event) { 
             const [mouseX, mouseY] = d3.pointer(event); const transform = appState.currentTransform; const invertedX = transform.invertX(mouseX); const invertedY = transform.invertY(mouseY); const clickRadius = (CONFIG.highlightRadius + 3) / transform.k; const targetPoint = appState.quadtree?.find(invertedX, invertedY, clickRadius); if (targetPoint) { const { width, height } = appState.dimensions.scatterplot; const targetScale = Math.min(CONFIG.zoomMax, Math.max(CONFIG.zoomMin, transform.k * 2)); const newTransform = d3.zoomIdentity.translate(width / 2, height / 2).scale(targetScale).translate(-targetPoint.px, -targetPoint.py); ELEMENTS.scatterplotCanvas.transition().duration(750).call(appState.behaviors.zoom.transform, newTransform); hideTooltip(); appState.hoveredPoint = null; appState.stickyPoint = null; updateSVGHoverHighlight(); updateSVGStickyHighlight(); }
         }
         function handleCanvasMouseOut(event) { 
             if (appState.hoveredPoint) { appState.hoveredPoint = null; updateSVGHoverHighlight(); } if (!appState.stickyPoint) { hideTooltip(); }
         }
         function handleTimelineBarMouseOver(event, d) { 
             appState.timelineHoveredBin = { x0: d.x0, x1: d.x1 }; drawScatterplot(); d3.select(event.currentTarget).style("fill", CONFIG.timelineBarHoverColor); // Use distinct hover color
         }
         function handleTimelineBarMouseOut(event, d) { 
             appState.timelineHoveredBin = null; drawScatterplot(); d3.select(event.currentTarget).style("fill", appState.colors.active); // Revert to dynamic active color
         }
        function handleResize() { 
            showLoading("Adjusting layout..."); setupDimensions(); appState.scales.x.range([0, appState.dimensions.scatterplot.width]); appState.scales.y.range([appState.dimensions.scatterplot.height, 0]); appState.scales.time.range([0, appState.dimensions.timeline.width]); appState.scales.count.range([appState.dimensions.timeline.height, 0]); appState.fullData.forEach(d => { d.px = appState.scales.x(d.x); d.py = appState.scales.y(d.y); }); appState.axes.xGrid.tickSize(-appState.dimensions.scatterplot.height); appState.axes.yGrid.tickSize(-appState.dimensions.scatterplot.width); setupSVGStructure(); setupCanvas(); appState.behaviors.zoom.translateExtent([[0, 0], [appState.dimensions.scatterplot.width, appState.dimensions.scatterplot.height]]).extent([[0, 0], [appState.dimensions.scatterplot.width, appState.dimensions.scatterplot.height]]); appState.behaviors.brush.extent([[0, 0], [appState.dimensions.timeline.width, appState.dimensions.timeline.height]]); ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush); const currentSelectionPixels = appState.currentFilters.dateRange ? appState.currentFilters.dateRange.map(appState.scales.time) : appState.scales.time.range(); setTimeout(() => { appState.isBrushing = true; ELEMENTS.timelineBrushGroup.call(appState.behaviors.brush.move, currentSelectionPixels); appState.isBrushing = false; }, 0); ELEMENTS.scatterplotCanvas.call(appState.behaviors.zoom.transform, appState.currentTransform); updateVisualization(); showLoading(false);
        }

        // --- Tooltip Functions (Unchanged) ---
        function showTooltip(event, data) { const pageX = event.pageX; const pageY = event.pageY; ELEMENTS.tooltip.style("display", "inline-block").style("right", `${0 + CONFIG.tooltipOffsetX + 15}px`).style("top", `${0 + CONFIG.tooltipOffsetY + 15}px`).html(`<strong>${data.title || 'N/A'}</strong><br>Author: ${data.author || 'N/A'}<br>Date: ${data.date.toLocaleDateString()}<br>Tags: ${data.tags?.length > 0 ? data.tags.join(', ') : 'None'}`); }
        function hideTooltip() { ELEMENTS.tooltip.style("display", "none"); }

        // --- UI Feedback Functions (Unchanged) ---
        function showLoading(message) { if (message) { ELEMENTS.loadingIndicator.text(message).style("display", "block"); } else { ELEMENTS.loadingIndicator.style("display", "none"); } }
        function displayError(message) { ELEMENTS.errorDisplay.text(`Error: ${message}`).style("display", "block"); }
        function updateFilterSummary() { const count = appState.filteredData.length; let base = `Showing ${count} of ${appState.fullData.length} articles`; const filtersActive = []; const f = appState.currentFilters; if (f.rawQuery.trim()) { filtersActive.push(`matching query "${f.rawQuery}"`); } if (f.dateRange) { const fmt = d3.timeFormat("%b %d, %Y"); const start = fmt(f.dateRange[0]); const end = fmt(f.dateRange[1]); if (d3.timeDay.count(f.dateRange[0], f.dateRange[1]) < 1) { filtersActive.push(`from ${start}`); } else { filtersActive.push(`from ${start} to ${end}`); } } if (filtersActive.length > 0) { base += ", filtered by: " + filtersActive.join(" and ") + "."; } else { base += " (no filters applied)."; } if (f.queryError) { base += ` (Query error: ${f.queryError})`; } ELEMENTS.filterSummary.text(base); }

        // --- Utility Function (Unchanged) ---
        function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func.apply(this, args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

        // --- Start the application ---
        initialize();

    </script>
</body>
</html>
